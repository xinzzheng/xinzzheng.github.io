{"meta":{"title":"Xin Blog","subtitle":"xinzzheng","description":"Practice makes perfect.","author":"Xin Zheng","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2019-04-03T05:36:30.000Z","updated":"2019-05-05T12:43:46.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"联系方式 手机：18896713412 Email：371635013@qq.com 微信号：18896713412 个人信息 郑鑫/男/1991.09 硕士/东南大学计算机专业 工作年限：2年 技术博客：http://xinzzheng.github.io/about/ 期望职位：Java软件开发 期望城市：苏州 工作经历苏州甲骨文软件系统公司 （ 2017年7月 ~ 2019年5月 ）Oracle Fusion Supply Chain Management SCM是一个进行协作式多系统订单执行和供应链管理系统。 主要参与供应链管理中的需求订单处理模块的开发，如分布式订单调配和分享式服务采购。 开发过程使用JAVA技术，开发工具为Linux环境下的JDeveloper，熟练使用Oracle数据库。 与美国印度多团队合作开发，熟悉英文技术文档的编写与业务汇报。 参与多模块联合的服务端性能优化，主要负责的是服务器内存的调优，熟悉内存分析工具MAT的使用。 维护Planning新功能开发与升级，多次直接与客户沟通，解决bug。 技能清单 熟练的使用Java语言进行面向对象程序设计，有良好的编程习惯。 熟悉Java Web开发，有MVC架构模式进行Java Web项目开发的经验。 熟练的运用Spring框架，熟悉Spring对其他框架的整合。 熟练的使用Hibernate、MyBatis等ORM框架，熟悉Hibernate和MyBatis的核心API。 熟悉常用的关系型数据库产品(MySQL、Oracle)。 熟练使用Eclipse/IDEA、GIT/SVN、Maven项目管理和项目构建工具。 操作系统:基于linux/ mac/ 开发。 个人总结 熟悉计算机行业，热爱开源，了解相关知识，有编写个人技术博客的习惯; 适应英文读写，听力良好，沟通顺利; 适应有压力的工作以及良好的编码规范与编写能力; 良好的钻研能力、学习能力、团队协作能力。 致谢感谢您花时间阅读我的简历，期待能有机会和您共事。"},{"title":"文章分类","date":"2019-03-30T14:08:08.000Z","updated":"2019-04-01T01:22:36.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-30T13:52:31.000Z","updated":"2019-04-01T01:25:25.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM 知识图谱","slug":"JVM-知识图谱","date":"2019-05-06T07:01:17.000Z","updated":"2019-05-06T08:34:06.000Z","comments":true,"path":"2019/05/06/JVM-知识图谱/","link":"","permalink":"http://yoursite.com/2019/05/06/JVM-知识图谱/","excerpt":"JVM的内存结构 堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。 方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。","text":"JVM的内存结构 堆（Heap）：线程共享。所有的对象实例以及数组都要在堆上分配。回收器主要管理的对象。 方法区（Method Area）：线程共享。存储类信息、常量、静态变量、即时编译器编译后的代码。 方法栈（JVM Stack）：线程私有。存储局部变量表、操作栈、动态链接、方法出口，对象指针。 本地方法栈（Native Method Stack）：线程私有。为虚拟机使用到的Native 方法服务。如Java使用c或者c++编写的接口服务时，代码在此区运行。 程序计数器（Program Counter Register）：线程私有。有些文章也翻译成PC寄存器（PC Register），同一个东西。它可以看作是当前线程所执行的字节码的行号指示器。指向下一条要执行的指令。 Java创建对象的方法 new A a1 = new A(); 反射 1234567A a2 = (A)Class.forName(\"A\").newInstance();A a3 = A.class.newInstance();A a4 = A.class.getConstructor().newInstance(); Clone 123456789public class A implements Cloneable&#123; @Override protected Object clone() throws CloneNotSupportedException &#123; // TODO Auto-generated method stub return super.clone(); &#125;&#125;A a5 = (A) a4.clone(); Deserialization 123456789public class A implements Cloneable, Serializable&#123;&#125; ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"A\")); output.writeObject(a5); output.close(); ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"A\")); A a6 = (A) input.readObject(); Java对象创建过程","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"序列化和反序列化的底层实现原理","slug":"序列化和反序列化的底层实现原理","date":"2019-05-06T01:38:01.000Z","updated":"2019-05-06T03:04:39.000Z","comments":true,"path":"2019/05/06/序列化和反序列化的底层实现原理/","link":"","permalink":"http://yoursite.com/2019/05/06/序列化和反序列化的底层实现原理/","excerpt":"序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。 反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。","text":"序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存了Java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。 反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。 用途 永久性保存对象，保存对象的字节序列到本地文件或者数据库中； 通过序列化以字节流的形式使对象在网络中进行传递和接收； 通过序列化在进程间传递对象； 要求 只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常！ 实现Java对象序列化与反序列化的方法实现了Serializable接口 ObjectOutputStream采用默认的序列化方式，对Obj对象的非transient的实例变量进行序列化。 ObjcetInputStream采用默认的反序列化方式，对Obj对象的非transient的实例变量进行反序列化。 实现了Serializable接口，且还定义了readObject/writeObject ObjectOutputStream调用Obj对象的writeObject(ObjectOutputStream out)的方法进行序列化。 ObjectInputStream会调用Obj对象的readObject(ObjectInputStream in)的方法进行反序列化。 实现了Externalnalizable接口，必须实现readExternal/writeExternal ObjectOutputStream调用Obj对象的writeExternal(ObjectOutput out))的方法进行序列化。 ObjectInputStream会调用Obj对象的readExternal(ObjectInput in)的方法进行反序列化。 Tips 序列化时，只对对象的状态进行保存，而不管对象的方法； 当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； 当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； 并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如： 安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的； 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现； 声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。 序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途： 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID； 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的； 如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因；","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Redis 内容体系","slug":"Redis-内容体系","date":"2019-05-06T01:12:08.000Z","updated":"2019-05-06T01:32:34.000Z","comments":true,"path":"2019/05/06/Redis-内容体系/","link":"","permalink":"http://yoursite.com/2019/05/06/Redis-内容体系/","excerpt":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI 、C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。","text":"REmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI 、C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 优点速度快 绝大部分请求是纯粹的内存操作，非常快速； 使用了很多查找操作都特别快的数据结构进行数据存储，Redis中的数据结构是专门设计的。如HashMap，查找、插入的时间复杂度都是O(1)； 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁、释放锁操作，没有因为可能出现死锁而导致的性能消耗； 用到了非阻塞I/O多路复用机制。 丰富的数据类型 String List Hash set zset 原子性，支持事务 Redis支持事务，并且它的所有操作都是原子性的，同时Redis还支持对几个操作合并后的原子性执行。 丰富的特性Redis具有丰富的特性，比如可以用作分布式锁；可以持久化数据；可以用作消息队列、排行榜、计数器；还支持publish/subscribe、通知、key过期等等。当我们要用中间件来解决实际问题的时候，Redis总能发挥出自己的用处。 Redis和Memcache对比存储方式 Memcache把数据全部存在内存之中，断电后会挂掉，无法做到数据的持久化，且数据不能超过内存大小。 Redis有一部分数据存在硬盘上，可以做到数据的持久性。 数据支持类型 Memcache对数据类型支持相对简单，只支持String类型的数据结构。 Redis有丰富的数据类型，包括：String、List、Hash、Set、Zset。 使用的底层模型 它们之间底层实现方式以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM机制 ，因为一般的系统调用系统函数，会浪费一定的时间去移动和请求。 存储值大小 Redis最大可以存储1GB，而memcache只有1MB。 Redis存在的问题及解决方案缓存数据库的双写一致性的问题 问题：一致性的问题是分布式系统中很常见的问题。一致性一般分为两种：强一致性和最终一致性，当我们要满足强一致性的时候，Redis也无法做到完美无瑕，因为数据库和缓存双写，肯定会出现不一致的情况，Redis只能保证最终一致性。 第一种方式是给缓存设置一定的过期时间，在缓存过期之后会自动查询数据库，保证数据库和缓存的一致性。 如果不设置过期时间的话，我们首先要选取正确的更新策略：先更新数据库再删除缓存。但我们删除缓存的时候也可能出现某些问题，所以需要将要删除的缓存的key放到消息队列中去，不断重试，直到删除成功为止。 缓存雪崩问题 我们应该都在电影里看到过雪崩，开始很平静，然后一瞬间就开始崩塌，具有很强的毁灭性。这里也是一样的，我们执行代码的时候将很多缓存的实效时间设定成一样，接着这些缓存在同一时间都会实效，然后都会重新访问数据库更新数据，这样会导致数据库连接数过多、压力过大而崩溃。 设置缓存过期时间的时候加一个随机值。 设置双缓存，缓存1设置缓存时间，缓存2不设置，1过期后直接返回缓存2，并且启动一个进程去更新缓存1和2。 缓存穿透问题 缓存穿透是指一些非正常用户(黑客)故意去请求缓存中不存在的数据，导致所有的请求都集中到到数据库上，从而导致数据库连接异常。 利用互斥锁。缓存失效的时候，不能直接访问数据库，而是要先获取到锁，才能去请求数据库。没得到锁，则休眠一段时间后重试。 采用异步更新策略。无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。 提供一个能迅速判断请求是否有效的拦截机制。比如利用布隆过滤器，内部维护一系列合法有效的key，迅速判断出请求所携带的Key是否合法有效。如果不合法，则直接返回。 缓存的并发竞争问题 缓存并发竞争的问题，主要发生在多线程对某个key进行set的时候，这时会出现数据不一致的情况。比如Redis中我们存着一个key为amount的值，它的value是100，两个线程同时都对value加100然后更新，正确的结果应该是变为300。但是两个线程拿到这个值的时候都是100，最后结果也就是200，这就导致了缓存的并发竞争问题。 如果多线程操作没有顺序要求的话，我们可以设置一个分布式锁，然后多个线程去争夺锁，谁先抢到锁谁就可以先执行。这个分布式锁可以用zookeeper或者Redis本身去实现。 可以利用Redis的incr命令。 当我们的多线程操作需要顺序的时候，我们可以设置一个消息队列，把需要的操作加到消息队列中去，严格按照队列的先后执行命令。 Redis的过期策略 Redis随着数据的增多，内存占用率会持续变高，我们以为一些键到达设置的删除时间就会被删除，但是时间到了，内存的占用率还是很高，这是为什么呢？ Redis采用的是定期删除和惰性删除的内存淘汰机制。 定期删除定期删除和定时删除是有区别的： 定时删除是必须严格按照设定的时间去删除缓存，这就需要我们设置一个定时器去不断地轮询所有的key，判断是否需要进行删除。但是这样的话cpu的资源会被大幅度地占据，资源的利用率变低。所以我们选择采用定期删除，。 定期删除是时间由我们定，我们可以每隔100ms进行检查，但还是不能检查所有的缓存，Redis还是会卡死，只能随机地去检查一部分缓存，但是这样会有一些缓存无法在规定时间内删除。这时惰性删除就派上用场了。 惰性删除举个简单的例子：中学的时候，平时作业太多，根本做不完，老师说下节课要讲这个卷子，你们都做完了吧？其实有很多人没做完，所以需要在下节课之前赶紧补上。 惰性删除也是这个道理，我们的这个值按理说应该没了，但是它还在，当你要获取这个key的时候，发现这个key应该过期了，赶紧删了，然后返回一个’没有这个值，已经过期了!’。 现在我们有了定期删除 + 惰性删除的过期策略，就可以高枕无忧了吗？并不是这样的，如果这个key一直不访问，那么它会一直滞留，也是不合理的，这就需要我们的内存淘汰机制了。 Redis内存淘汰策略 在Redis.conf中我们可以进行配置1# maxmemory-policy allkeys-lru","categories":[{"name":"Redis系列","slug":"Redis系列","permalink":"http://yoursite.com/categories/Redis系列/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Spring Boot(二)","slug":"Spring-Boot-二","date":"2019-04-29T02:46:10.000Z","updated":"2019-04-29T02:51:28.000Z","comments":true,"path":"2019/04/29/Spring-Boot-二/","link":"","permalink":"http://yoursite.com/2019/04/29/Spring-Boot-二/","excerpt":"Spring Boot 核心为什么我们要用 Spring Boot","text":"Spring Boot 核心为什么我们要用 Spring Boot Spring Boot 最主要是不用 XML 配置，可以用 Java 来配置 bean，省去了许多配置文件。 Spring Boot 我们用来做 Spring Cloud 微服务。 Spring Boot 可以打 jar 包部署，内部集成了Tomcat。 Spring Boot 最重要的功能是：自动配置。 Spring Boot 的开启注解是：@SpringBootApplication，其实它就是由下面三个注解组成的： @Configuration @ComponentScan @EnableAutoConfiguration 上面三个注解，前面两个都是 Spring 自带的，和 Spring Boot 无关，所以说 Spring Boot 最最核心的就是这个 @EnableAutoConfiguration 注解了，它能根据类路径下的 jar 包和配置动态加载配置和注入bean。 举个例子，比如我在 lib 下放一个 druid 连接池的 jar 包，然后在 application.yml 文件配置 druid 相关的参数，Spring Boot 就能够自动配置所有我们需要的东西，如果我把 jar 包拿掉或者把参数去掉，那 Spring Boot 就不会自动配置。这样我们就能把许多功能做成公共的自动配置的启动器（starters），其实 druid 连接池就是这么做的，它提供了针对 Spring Boot 的启动器：druid-spring-boot-starter。有了这个自动配置的启动器，我们就能非常简单的使用它， 先添加 jar 包依赖：12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 再添加相关参数：123spring.datasource.url= spring.datasource.username=spring.datasource.password= 如果是传统的项目，我们要自己手动写一大堆的配置，而且还不灵活，有了这个启动器，我们就可以做到简单集成。","categories":[{"name":"Spring Boot系列","slug":"Spring-Boot系列","permalink":"http://yoursite.com/categories/Spring-Boot系列/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Eclipse添加XML约束","slug":"Eclipse添加XML约束","date":"2019-04-27T09:35:23.000Z","updated":"2019-04-27T10:00:23.000Z","comments":true,"path":"2019/04/27/Eclipse添加XML约束/","link":"","permalink":"http://yoursite.com/2019/04/27/Eclipse添加XML约束/","excerpt":"xml约束文件一般后缀名为.dtd或者.xsd，通过添加这些约束，可以方便我们在eclipse中编码xml文件（智能提示、格式错误提示等）。","text":"xml约束文件一般后缀名为.dtd或者.xsd，通过添加这些约束，可以方便我们在eclipse中编码xml文件（智能提示、格式错误提示等）。 Preferences, 搜索框中输入”cata“ 选中XML Catalog，点击右侧的Add， 选择File System…;Key type下拉列表中选Schema location： Key中，把Location中的文件名（不包含路径）复制到添加‘/’的Key后面，点击OK 选择进入Design模式，右击beans标签，选择Edit namespace，点击Add，选中xsi，点击OK 再点Add，选择Specify New Namespace，在Location Hint的右侧选择Browse，选择Select XML Catalog entry，找到之前添加的约束，点击OK 将Namespace Name中输入Location Hint中没有文件名的路径名，点击OK","categories":[{"name":"Mac系列","slug":"Mac系列","permalink":"http://yoursite.com/categories/Mac系列/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"解决Linux/macOS下zip文件解压中文乱码","slug":"解决Linux-macOS下zip文件解压中文乱码","date":"2019-04-26T07:18:54.000Z","updated":"2019-04-27T12:24:28.000Z","comments":true,"path":"2019/04/26/解决Linux-macOS下zip文件解压中文乱码/","link":"","permalink":"http://yoursite.com/2019/04/26/解决Linux-macOS下zip文件解压中文乱码/","excerpt":"原因很多网站下载的zip文件都是在Windows下打包的，这就为乱码的出现埋下了铺垫。这个问题表面上是由于Windows(中文系统)下使用cp936也就是GBK编码，而Linux以及macOS下使用UTF-8编码，但是追根究底还是因为zip格式在设计之初就没有为文件编码预留存储数据的位置，导致解压程序在解压时只能依照系统编码进行解压，这种情况下一旦跨平台解压就可能导致中文乱码。","text":"原因很多网站下载的zip文件都是在Windows下打包的，这就为乱码的出现埋下了铺垫。这个问题表面上是由于Windows(中文系统)下使用cp936也就是GBK编码，而Linux以及macOS下使用UTF-8编码，但是追根究底还是因为zip格式在设计之初就没有为文件编码预留存储数据的位置，导致解压程序在解压时只能依照系统编码进行解压，这种情况下一旦跨平台解压就可能导致中文乱码。 解决Python12345678910111213141516171819202122#!/usr/bin/env python# -*- coding: utf-8 -*-import osimport sysimport zipfile# print \"Processing File \" + sys.argv[1]file = zipfile.ZipFile(sys.argv[1], \"r\")for name in file.namelist(): utf8name = name.decode('gbk')# print \"Extracting \" + utf8name pathname = os.path.dirname(utf8name) if not os.path.exists(pathname) and pathname != \"\": os.makedirs(pathname) data = file.read(name) if not os.path.exists(utf8name): fo = open(utf8name, \"w\") fo.write(data) fo.closefile.close() chmod 777 Myunzip.py./Myunzip.py *.zip unar 安装brewruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装unarbrew install unar 使用unarunar -e GBK *.zip","categories":[{"name":"Mac系列","slug":"Mac系列","permalink":"http://yoursite.com/categories/Mac系列/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"Spring Boot(一)","slug":"Spring-Boot-一","date":"2019-04-26T06:01:02.000Z","updated":"2019-04-26T07:46:38.000Z","comments":true,"path":"2019/04/26/Spring-Boot-一/","link":"","permalink":"http://yoursite.com/2019/04/26/Spring-Boot-一/","excerpt":"Spring Boot 入门Spring Boot 介绍 从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。","text":"Spring Boot 入门Spring Boot 介绍 从本质上来说，Spring Boot就是Spring,它做了那些没有它你也会去做的Spring Bean配置。 核心 自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置 起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。 命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。 Actuator：让你能够深入运行中的Spring Boot应用程序，一套究竟。 系统要求 Spring Boot 2.1.3 Java 8 Maven 3 快读入门pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.xinzhe&lt;/groupId&gt; &lt;artifactId&gt;SpringBoot_01&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo01&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 应用类","categories":[{"name":"Spring Boot系列","slug":"Spring-Boot系列","permalink":"http://yoursite.com/categories/Spring-Boot系列/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Redis-配置与启动","slug":"Redis-配置与启动","date":"2019-04-09T05:51:52.000Z","updated":"2019-04-27T12:27:56.000Z","comments":true,"path":"2019/04/09/Redis-配置与启动/","link":"","permalink":"http://yoursite.com/2019/04/09/Redis-配置与启动/","excerpt":"Mac下安装及配置redis 下载 redis 安装包 拷贝压缩包到 【/usr/local 】目录； 解压缩 sudo tar -zxf redis-X.X.X.tar.gz; 进入解压缩后的目录 cd redis-X.X.X; 编译测试 sudo make test 编译安装 sudo make install","text":"Mac下安装及配置redis 下载 redis 安装包 拷贝压缩包到 【/usr/local 】目录； 解压缩 sudo tar -zxf redis-X.X.X.tar.gz; 进入解压缩后的目录 cd redis-X.X.X; 编译测试 sudo make test 编译安装 sudo make install 配置一，建立工作目录 【/usr/local/redis】（接下来的几步操作均以该目录为根目录） 配置二，进入工作目录，建立子目录：bin、etc、db，命令 sudo mkdir /usr/local/redis/目录名 配置三，把上面解压的 【redis-X.X.X/src】目录下的mkreleasehdr.sh、redis-benchmark、 redis-check-dump、 redis-cli、 redis-server 共 5 个文件 拷贝到【/usr/local/redis/bin】目录下 配置四，在 【etc】目录下建立 redis.conf 文件；启动服务 bin/redis-server 常用命令 启动服务端：redis-server /usr/local/redis-4.0.1/etc/redis.conf 关闭服务： redis-cli shutdown 查看日志文件：tail -f log-redis.log 检查是否启动：redis-cli ping 启动客户端： redis-cli 关闭客户端： quit","categories":[{"name":"Redis系列","slug":"Redis系列","permalink":"http://yoursite.com/categories/Redis系列/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"Redis-配置与启动","slug":"Spring简介以及常用配置","date":"2019-04-09T05:51:52.000Z","updated":"2019-04-27T12:28:19.000Z","comments":true,"path":"2019/04/09/Spring简介以及常用配置/","link":"","permalink":"http://yoursite.com/2019/04/09/Spring简介以及常用配置/","excerpt":"SpringIOC 和 DI IOC： 控制反转，将对象的创建权反转给Spring。 DI: 依赖注入， 前提必须有IOC的环境，Spring管理这个类的时候将类的依赖的属性注入（设置）进来。","text":"SpringIOC 和 DI IOC： 控制反转，将对象的创建权反转给Spring。 DI: 依赖注入， 前提必须有IOC的环境，Spring管理这个类的时候将类的依赖的属性注入（设置）进来。 面向对象之间的关系： 依赖 继承 聚合 ApplicationContext ApplicationContext: 加载配置文件的时候，会将Spring管理的类都实例化。 ApplicationContext：实现类： ClassPathXmlApplicationContext : 类路径 FileSystemXmlApplicationContext ：文件路径 Bean的相关配置 id : 唯一约束，无特殊字符 name ：不唯一，可以特殊 class : 实例全路径 Bean 生命周期配置 init-method: Bean被初始化的时候执行的方 destroy-method :Bean被销毁的时候执行的方法（Bean是单例创建，工厂关闭） Bean 作用范围配置 scope singleton ： 单例模式创建对象 prototype : 多例模式 request ： 应用在web项目中，创建这个类后，将这个类存入request范围中。 session : 应用在web项目中，创建这个类后，将这个类存入session范围中。 globalsession ： 应用在web项目中，必须在porlet环境中使用。 属性注入（DI）构造方法提供一个带参数的构造方法。 setter提供set方法 接口注入123456789public interface injection&#123; public void setName(String name);&#125;public class User implements injection&#123; private String name; public void setName(String name)&#123; this.name = name; &#125;&#125;","categories":[{"name":"Spring系列","slug":"Spring系列","permalink":"http://yoursite.com/categories/Spring系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://yoursite.com/tags/spring/"}]},{"title":"Cookie and Session","slug":"Cookie-and-Session","date":"2019-04-08T07:31:40.000Z","updated":"2019-04-26T07:38:19.000Z","comments":true,"path":"2019/04/08/Cookie-and-Session/","link":"","permalink":"http://yoursite.com/2019/04/08/Cookie-and-Session/","excerpt":"Cookie为什么要有Cookie http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯.","text":"Cookie为什么要有Cookie http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯. Cookie怎么用 添加Cookie给客户端 在响应的时候，添加cookie Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;); //给响应，添加一个cookie response.addCookie(cookie); 2. 客户端收到的信息里面，响应头中多了一个字段 Set-Cookie 获取客户端带过来的Cookie //获取客户端带过来的cookie Cookie[] cookies = request.getCookies(); if(cookies != null){ for (Cookie c : cookies) { String cookieName = c.getName(); String cookieValue = c.getValue(); System.out.println(cookieName + &quot; = &quot;+ cookieValue); } } 常用方法 //关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。 // expiry： 有效 以秒计算。 //正值 ： 表示 在这个数字过后，cookie将会失效。 //负值： 关闭浏览器，那么cookie就失效， 默认值是 -1 cookie.setMaxAge(60 * 60 * 24 * 7); //赋值新的值 //cookie.setValue(newValue); //用于指定只有请求了指定的域名，才会带上该cookie cookie.setDomain(&quot;.itheima.com&quot;); //只有访问该域名下的cookieDemo的这个路径地址才会带cookie cookie.setPath(&quot;/CookieDemo&quot;); ###Cookie总结 服务器给客户端发送过来的一小份数据，并且存放在客户端上。 获取cookie， 添加cookie request.getCookie(); response.addCookie(); Cookie分类 会话Cookie 默认情况下，关闭了浏览器，那么cookie就会消失。 持久Cookie 在一定时间内，都有效，并且会保存在客户端上。 cookie.setMaxAge(0); //设置立即删除 cookie.setMaxAge(100); //100 秒 Cookie的安全问题。 由于Cookie会保存在客户端上，所以有安全隐患问题。 还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 —&gt; Session . Session 会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。 常用API //得到会话ID String id = session.getId(); //存值 session.setAttribute(name, value); //取值 session.getAttribute(name); //移除值 session.removeAttribute(name); Session何时创建 ， 何时销毁? 创建 如果有在servlet里面调用了 request.getSession() 销毁 session 是存放在服务器的内存中的一份数据。 当然可以持久化. Redis . 即使关了浏览器，session也不会销毁。 关闭服务器 session会话时间过期。 有效期过了，默认有效期： 30分钟。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://yoursite.com/categories/Java-Web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://yoursite.com/tags/java-web/"}]},{"title":"Git Command","slug":"Git-Command","date":"2019-04-08T06:56:39.000Z","updated":"2019-04-26T07:38:43.000Z","comments":true,"path":"2019/04/08/Git-Command/","link":"","permalink":"http://yoursite.com/2019/04/08/Git-Command/","excerpt":"常用git命令常规操作：","text":"常用git命令常规操作： git clone &lt;地址&gt; 新建本地分支 git checkout -b &lt;开发分支&gt; 更新远端分支 git fetch 拉取远端的更新 git pull origin &lt;分支名&gt; 切换本地分支 git checkout &lt;分支名&gt; 合并主分支到当前分支 git merge master 推送本地分支到远端 git push origin &lt;开发分支&gt; 查看本地分支 git branch 查看本地分支以及远端分支 git branch -a git config --global http.proxy http://cn-proxy.jp.oracle.com:80 创建本地跟踪分支 git checkout -b branchname origin/branchname 删除本地分支 git branch -D &lt;branch_name&gt; 重置工作区的一个文件到最近的一次提交 git reset HEAD &lt;file&gt; 重置工作区的所有文件到最近的一次提交（注意最后的点） git reset HEAD . 强制重置工作区的所有文件到最近的一次提交 git reset --hard HEAD^git checkout -- .git push origin --delete &lt;branch_name&gt;git push --force origin &lt;branch_name&gt; 恢复git checkout origin/master -- ScoCore/ScoCore.jpr 删除远端分支 git push origin --delete &lt;branch_name&gt; 强制更新远端分支 git push --force origin &lt;branch_name&gt;","categories":[{"name":"Oracle Tools","slug":"Oracle-Tools","permalink":"http://yoursite.com/categories/Oracle-Tools/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"Servlet页面跳转方法","slug":"Servlet页面跳转方法","date":"2019-04-08T03:14:20.000Z","updated":"2019-04-26T07:41:46.000Z","comments":true,"path":"2019/04/08/Servlet页面跳转方法/","link":"","permalink":"http://yoursite.com/2019/04/08/Servlet页面跳转方法/","excerpt":"Servlet 页面跳转的方法请求转发和重定向重定向","text":"Servlet 页面跳转的方法请求转发和重定向重定向 /* 之前的写法 response.setStatus(302); response.setHeader(&quot;Location&quot;, &quot;login_success.html&quot;);*/ //重定向写法： 重新定位方向 参数即跳转的位置 response.sendRedirect(&quot;login_success.html&quot;); 1. 地址上显示的是最后的那个资源的路径地址 2. 请求次数最少有两次， 服务器在第一次请求后，会返回302 以及一个地址， 浏览器在根据这个地址，执行第二次访问。 3. 可以跳转到任意路径。 不是自己的工程也可以跳。 4. 效率稍微低一点， 执行两次请求。 5. 后续的请求，没法使用上一次的request存储的数据，或者 没法使用上一次的request对象，因为这是两次不同的请求。 请求转发//请求转发的写法： 参数即跳转的位置 request.getRequestDispatcher(&quot;login_success.html&quot;).forward(request, response); 1. 地址上显示的是请求servlet的地址。 返回200 ok 2. 请求次数只有一次， 因为是服务器内部帮客户端执行了后续的工作。 3. 只能跳转自己项目的资源路径 。 4. 效率上稍微高一点，因为只执行一次请求。 5. 可以使用上一次的request对象。 方法1.RequestDispatcher.forward() 服务器端跳转 跳转至Servlet, Jsp, Html, 重定向后浏览器地址栏URL不变。 传递参数 通常在servlet中使用，不在jsp中使用。 123456789public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException &#123; response.setContentType(\"text/html; charset=gb2312\"); ServletContext sc = getServletContext(); RequestDispatcher rd = null; rd = sc.getRequestDispatcher(\"/index.jsp\"); //定向的页面 rd.forward(request, response); &#125; 2.response.sendRedirect() 用户的浏览器端工作 重定向后在浏览器地址栏上会出现重定向页面的URL 在jsp页面中可以用response.sendRedirect()直接实现重定位。 123456public void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException &#123; response.setContentType(\"text/html; charset=gb2312\"); response.sendRedirect(\"/index.jsp\"); &#125; 3.Jsp ＜jsp:forward page=”” /＞它的底层部分是由RequestDispatcher来实现的，因此它带有RequestDispatcher.forward()方法的印记。 如果在之前有很多输出,前面的输出已使缓冲区满,将自动输出到客户端,那么该语句将不起作用,这一点应该特别注意。 另外要注意：它不能改变浏览器地址，刷新的话会导致重复提交 4.修改HTTP header的Location属性来重定向12345＜% response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY); String newLocn = \"/newpath/jsa.jsp\"; response.setHeader(\"Location\",newLocn); %＞ 5.JSP中实现在某页面停留若干秒后,自动重定向到另一页面 在html文件中，下面的代码：＜meta http-equiv=&quot;refresh&quot; content=&quot;300; url=target.jsp&quot;＞ 它的含义：在5分钟之后正在浏览的页面将会自动变为target.html这一页。代码中300为刷新的延迟时间，以秒为单位。targer.html为你想转向的目标页,若为本页则为自动刷新本页。 由上可知，可以通过setHeader来实现某页面停留若干秒后,自动重定向到另一页面。 12String content=stayTime+\";URL=\"+URL; response.setHeader(\"REFRESH\",content); ReferenceJSP页面的五种跳转方法","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://yoursite.com/categories/Java-Web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://yoursite.com/tags/java-web/"}]},{"title":"Mac Eclipse 配置","slug":"Mac-Eclipse-配置","date":"2019-04-08T02:20:39.000Z","updated":"2019-04-26T07:41:25.000Z","comments":true,"path":"2019/04/08/Mac-Eclipse-配置/","link":"","permalink":"http://yoursite.com/2019/04/08/Mac-Eclipse-配置/","excerpt":"Eclipse 代码自动提示设置","text":"Eclipse 代码自动提示设置 打开Eclipse，然后 “Eclipse” → “偏好设置” 选择“java”，展开，“Editor”，选择“Content Assist”。 选择“Content Assist”，然后看到右边，右边的“Auto-Activation”下面的“Auto Activation triggers for java”这个选项。其实就是指触发代码提示的就是“.”这个符号。 “Auto Activation triggers for java”这个选项，在“.”后加abc字母，方便后面的查找修改。然后“apply”，点击“OK”。 然后，“File”→“Export”，在弹出的窗口中选择 ”General“ → “Perferences” ，点击“下一步”。 选择导出文件路径，本人导出到桌面，输入“test”作为文件名，点击“保存”。 在桌面找到刚在保存的文件“test.epf”,右键选择“用记事本打开”。 可以看到很多配置Eclipse的信息 按“ctrl + F”快捷键，输入“.abc”，点击“查找下一个”。 查找到“.abc”的配置信息如下： 把“.abc”改成“.abcdefghijklmnopqrstuvwxyz(,”，保存，关闭“test.epf”。 回到Eclipse界面，“File”→“Import”，在弹出的窗口中选择 ”General“ → “Perferences” ，点击“下一步”，选择刚在已经修改的“test.epf”文件，点击“打开”，点击“Finish”。该步骤和上面的导出步骤类似。 快捷键 快捷修复 12345Command+1 //int a=100L;//int a=(int) 100L; 快捷删除行 Command+D 快速起新行 Shift+Enter （当本行代码很长时，将光标定在本行任意位置，用这个快捷键可以快速到达新行的开头处） 将光标快速放到正确格式的位置 Tab键 当光标在行首时，用Tab键可以将光标快速放到正确格式的位置 快速运行项目 (Fn+)Command+F11 //System.out.println(“Run2”); 快速移动代码（可以多行） Alt+上下箭头 快速复制代码 Command+Alt+上下箭头 快速注释 Command+/ 多行注释或给方法列出参数注释 输入”/**”+回车 放大当前工作区窗口 Ctrl+M 快速代码补全 Alt+/ 如：输入“syso” 然后用”Alt+/“,就可以将代码输入为“System.out.println();” 自动导包 ctrl+shift+o","categories":[{"name":"Mac系列","slug":"Mac系列","permalink":"http://yoursite.com/categories/Mac系列/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"Http and Servlet","slug":"Http-and-Servlet","date":"2019-04-07T14:47:16.000Z","updated":"2019-04-26T07:39:00.000Z","comments":true,"path":"2019/04/07/Http-and-Servlet/","link":"","permalink":"http://yoursite.com/2019/04/07/Http-and-Servlet/","excerpt":"Http协议&amp;ServletHttp协议 什么是协议 双方在交互、通讯的时候， 遵守的一种规范、规则。","text":"Http协议&amp;ServletHttp协议 什么是协议 双方在交互、通讯的时候， 遵守的一种规范、规则。 http协议 针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 其实就是规定了客户端在访问服务器端的时候，要带上哪些东西， 服务器端返回数据的时候，也要带上什么东西。 版本 1.0 请求数据，服务器返回后， 将会断开连接 1.1 请求数据，服务器返回后， 连接还会保持着。 除非服务器 | 客户端 关掉。 有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。 演示客户端 如何 与服务器端通讯。 在地址栏中键入网络地址 回车 或者是平常注册的时候，点击了注册按钮 ， 浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯。 它们都传输了哪些数据。 安装抓包工具 HttpWatch (IE插件) 打开tomcat. 输入localhost:8080 打开首页 在首页上找到Example 字样 6.x 和 7.x 的文档页面有所不同，但是只要找到example就能够找到例子工程 Http请求数据解释 请求的数据里面包含三个部分内容 ： 请求行 、 请求头 、请求体 请求行 POST /examples/servlets/servlet/RequestParamExample HTTP/1.1 POST ： 请求方式 ，以post去提交数据 /examples/servlets/servlet/RequestParamExample 请求的地址路径 ， 就是要访问哪个地方。 HTTP/1.1 协议版本 请求头 Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */* Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample Accept-Language: zh-CN User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) Content-Type: application/x-www-form-urlencoded Accept-Encoding: gzip, deflate Host: localhost:8080 Content-Length: 31 Connection: Keep-Alive Cache-Control: no-cache Accept: 客户端向服务器端表示，我能支持什么类型的数据。 Referer ： 真正请求的地址路径，全路径 Accept-Language: 支持语言格式 User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据 Accept-Encoding： gzip, deflate ： 压缩算法 。 Host ： 主机地址 Content-Length： 数据长度 Connection : Keep-Alive 保持连接 Cache-Control ： 对缓存的操作 请求体 浏览器真正发送给服务器的数据 发送的数据呈现的是key=value ,如果存在多个数据，那么使用 &amp; firstname=zhang&amp;lastname=sansan Http响应数据解析 请求的数据里面包含三个部分内容 ： 响应行 、 响应头 、响应体 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 673 Date: Fri, 17 Feb 2017 02:53:02 GMT ...这里还有很多数据... 响应行 HTTP/1.1 200 OK 协议版本 状态码 咱们这次交互到底是什么样结果的一个code. 200 : 成功，正常处理，得到数据。 403 : Forbidden 拒绝 404 ： Not Found 500 ： 服务器异常 OK 对应前面的状态码 响应头 Server: 服务器是哪一种类型。 Tomcat Content-Type ： 服务器返回给客户端你的内容类型 Content-Length ： 返回的数据长度 Date ： 通讯的日期，响应的时间 Get 和 Post请求区别 post 1. 数据是以流的方式写过去，不会在地址栏上面显示。 现在一般提交数据到服务器使用的都是POST 2. 以流的方式写数据，所以数据没有大小限制。 get 1. 会在地址栏后面拼接数据，所以有安全隐患。 一般从服务器获取数据，并且客户端也不用提交上面数据的时候，可以使用GET 2. 能够带的数据有限， 1kb大小 Web资源在http协议当中，规定了请求和响应双方， 客户端和服务器端。与web相关的资源。 有两种分类 静态资源 html 、 js、 css 动态资源 servlet/jsp Servlet servlet是什么? 其实就是一个java程序，运行在我们的web服务器上，用于接收和响应 客户端的http请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Hello Servlet 得写一个Web工程 ， 要有一个服务器。 测试运行Web工程 1. 新建一个类， 实现Servlet接口 2. 配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。 在webContent/WEB-INF/web.xml里面写上以下内容。 &lt;!-- 向tomcat报告， 我这个应用里面有这个servlet， 名字叫做HelloServlet , 具体的路径是com.itheima.servlet.HelloServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet， url-pattern: 在地址栏上的path 一定要以/打头 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3. 在地址栏上输入 http://localhost:8080/项目名称/a Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求） 定义一个类，继承HttpServlet 复写doGet 和 doPost Servlet的生命周期 生命周期 从创建到销毁的一段时间 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该servlet的实例时，就执行该方法。 一个servlet只会初始化一次， init方法只会执行一次 默认情况下是 ： 初次访问该servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用 destroy方法 servlet销毁的时候，就会执行该方法 1. 该项目从tomcat的里面移除。 2. 正常关闭tomcat就会执行 shutdown.bat doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机 提前。 默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; ServletConfig Servlet的配置，通过这个对象，可以获取servlet在配置的时候一些信息 先说 ， 在写怎么用， 最后说有什么用。 //1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); //2、。 可以获取具体的某一个参数。 String address = config.getInitParameter(&quot;address&quot;); System.out.println(&quot;address=&quot;+address); //3.获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); } 为什么需要有这个ServletConfig 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个servlet的公司，在注册servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。 刚才的这个实验， 希望基础好或者感兴趣的同学，回去自己做一下。 总结 Http协议 1. 使用HttpWacht 抓包看一看http请求背后的细节。 2. 基本了解 请求和响应的数据内容 请求行、 请求头 、请求体 响应行、响应头、响应体 3. Get和Post的区别 Servlet【重点】 1. 会使用简单的servlet 1.写一个类，实现接口Servlet 2. 配置Servlet 3. 会访问Setvlet 2. Servlet的生命周期 init 一次 创建对象 默认初次访问就会调用或者可以通过配置，让它提前 load-on-startup service 多次，一次请求对应一次service destory 一次 销毁的时候 从服务器移除 或者 正常关闭服务器 3. ServletConfig 获取配置的信息， params","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://yoursite.com/categories/Java-Web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://yoursite.com/tags/java-web/"}]},{"title":"XML and Tomcat","slug":"XML-and-Tomcat","date":"2019-04-07T06:53:09.000Z","updated":"2019-04-26T07:42:09.000Z","comments":true,"path":"2019/04/07/XML-and-Tomcat/","link":"","permalink":"http://yoursite.com/2019/04/07/XML-and-Tomcat/","excerpt":"Xml &amp; TomcatXml eXtendsible markup language 可扩展的标记语言","text":"Xml &amp; TomcatXml eXtendsible markup language 可扩展的标记语言 XML 有什么用? 可以用来保存数据 可以用来做配置文件 数据传输载体 定义xml 其实就是一个文件，文件的后缀为 .xml 文档声明简单声明， version : 解析这个xml的时候，使用什么版本的解析器解析 &lt;?xml version=&quot;1.0&quot; ?&gt; encoding : 解析xml中的文字的时候，使用什么编码来翻译 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot; ?&gt; standalone : no - 该文档会依赖关联其他文档 ， yes-- 这是一个独立的文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot; standalone=&quot;no&quot; ?&gt; encoding详解 在解析这个xml的时候，使用什么编码去解析。 —解码。 文字， 而是存储这些文字对应的二进制 。 那么这些文字对应的二进制到底是多少呢？ 根据文件使用的编码 来得到。 默认文件保存的时候，使用的是GBK的编码保存。 所以要想让我们的xml能够正常的显示中文，有两种解决办法 让encoding也是GBK 或者 gb2312 . 如果encoding是 utf-8 ， 那么保存文件的时候也必须使用utf-8 保存的时候见到的ANSI 对应的其实是我们的本地编码 GBK。 为了通用，建议使用UTF-8编码保存，以及encoding 都是 utf-8 元素定义（标签） 其实就是里面的标签， &lt;&gt; 括起来的都叫元素 。 成对出现。 如下： &lt;stu&gt; &lt;/stu&gt; 文档声明下来的第一个元素叫做根元素 (根标签) 标签里面可以嵌套标签 空标签 既是开始也是结束。 一般配合属性来用。 &lt;age/&gt; &lt;stu&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age/&gt; &lt;/stu&gt; 标签可以自定义。 XML 命名规则 XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 命名尽量简单，做到见名知义 简单元素 &amp; 复杂元素 简单元素 元素里面包含了普通的文字 复杂元素 元素里面还可以嵌套其他的元素 属性的定义 定义在元素里面， &lt;元素名称 属性名称=”属性的值”&gt;&lt;/元素名称&gt; 张三 18 李四 28 xml注释： 与html的注释一样。 &lt;!-- --&gt; 如： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- //这里有两个学生 //一个学生，名字叫张三， 年龄18岁， 学号：10086 //另外一个学生叫李四 。。。 --&gt; xml的注释，不允许放置在文档的第一行。 必须在文档声明的下面。 CDATA区 非法字符 严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。 &lt; &lt;&amp; &amp; 如果某段字符串里面有过多的字符， 并且里面包含了类似标签或者关键字的这种文字，不想让xml的解析器去解析。 那么可以使用CDATA来包装。 不过这个CDATA 一般比较少看到。 通常在服务器给客户端返回数据的时候。 &lt;des&gt;&lt;![CDATA[&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;]]&gt;&lt;/des&gt; XML 解析 其实就是获取元素里面的字符数据或者属性数据。 XML解析方式(面试常问) 有很多种，但是常用的有两种。 DOM SAX 针对这两种解析方式的API 一些组织或者公司， 针对以上两种解析方式， 给出的解决方案有哪些？ jaxp sun公司。 比较繁琐 jdom dom4j 使用比较广泛 Dom4j 基本用法element.element(&quot;stu&quot;) : 返回该元素下的第一个stu元素 element.elements(); 返回该元素下的所有子元素。 创建SaxReader对象 指定解析的xml 获取根元素。 根据根元素获取子元素或者下面的子孙元素 try { //1. 创建sax读取对象 SAXReader reader = new SAXReader(); //jdbc -- classloader //2. 指定解析的xml源 Document document = reader.read(new File(&quot;src/xml/stus.xml&quot;)); //3. 得到元素、 //得到根元素 Element rootElement= document.getRootElement(); //获取根元素下面的子元素 age //rootElement.element(&quot;age&quot;) //System.out.println(rootElement.element(&quot;stu&quot;).element(&quot;age&quot;).getText()); //获取根元素下面的所有子元素 。 stu元素 List&lt;Element&gt; elements = rootElement.elements(); //遍历所有的stu元素 for (Element element : elements) { //获取stu元素下面的name元素 String name = element.element(&quot;name&quot;).getText(); String age = element.element(&quot;age&quot;).getText(); String address = element.element(&quot;address&quot;).getText(); System.out.println(&quot;name=&quot;+name+&quot;==age+&quot;+age+&quot;==address=&quot;+address); } } catch (Exception e) { e.printStackTrace(); } SaxReader 创建好对象 。 DocumentElement 看文档 记住关键字 。 有对象先点一下。 看一下方法的返回值。 根据平时的积累。 getXXX setXXX Dom4j 的 Xpath使用 dom4j里面支持Xpath的写法。 xpath其实是xml的路径语言，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。 添加jar包依赖 jaxen-1.1-beta-6.jar 在查找指定节点的时候，根据XPath语法规则来查找 后续的代码与以前的解析代码一样。 //要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。 Element nameElement = (Element) rootElement.selectSingleNode(&quot;//name&quot;); System.out.println(nameElement.getText()); System.out.println(&quot;----------------&quot;); //获取文档里面的所有name元素 List&lt;Element&gt; list = rootElement.selectNodes(&quot;//name&quot;); for (Element element : list) { System.out.println(element.getText()); } XML 约束【了解】如下的文档， 属性的ID值是一样的。 这在生活中是不可能出现的。 并且第二个学生的姓名有好几个。 一般也很少。那么怎么规定ID的值唯一， 或者是元素只能出现一次，不能出现多次？ 甚至是规定里面只能出现具体的元素名字。 &lt;stus&gt; &lt;stu id=&quot;10086&quot;&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;address&gt;深圳&lt;/address&gt; &lt;/stu&gt; &lt;stu id=&quot;10086&quot;&gt; &lt;name&gt;李四&lt;/name&gt; &lt;name&gt;李五&lt;/name&gt; &lt;name&gt;李六&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;address&gt;北京&lt;/address&gt; &lt;/stu&gt; &lt;/stus&gt; DTD语法自成一派， 早起就出现的。 可读性比较差。 引入网络上的DTD &lt;!-- 引入dtd 来约束这个xml --&gt; &lt;!-- 文档类型 根标签名字 网络上的dtd dtd的名称 dtd的路径 &lt;!DOCTYPE stus PUBLIC &quot;//UNKNOWN/&quot; &quot;unknown.dtd&quot;&gt; --&gt; 引入本地的DTD 直接在XML里面嵌入DTD的约束规则 &lt;!-- xml文档里面直接嵌入DTD的约束法则 --&gt; &lt;!DOCTYPE stus [ &lt;!ELEMENT stus (stu)&gt; &lt;!ELEMENT stu (name,age)&gt; &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; ]&gt; &lt;stus&gt; &lt;stu&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/stu&gt; &lt;/stus&gt; &lt;!ELEMENT stus (stu)&gt; : stus 下面有一个元素 stu ， 但是只有一个 &lt;!ELEMENT stu (name , age)&gt; stu下面有两个元素 name ,age 顺序必须name-age &lt;!ELEMENT name (#PCDATA)&gt; &lt;!ELEMENT age (#PCDATA)&gt; &lt;!ATTLIST stu id CDATA #IMPLIED&gt; stu有一个属性 文本类型， 该属性可有可无 元素的个数： ＋ 一个或多个 * 零个或多个 ? 零个或一个 属性的类型定义 CDATA : 属性是普通文字 ID : 属性的值必须唯一 &lt;!ELEMENT stu (name , age)&gt; 按照顺序来 &lt;!ELEMENT stu (name | age)&gt; 两个中只能包含一个子元素 Schema其实就是一个xml ， 使用xml的语法规则， xml解析器解析起来比较方便 ， 是为了替代DTD 。 但是Schema 约束文本内容比DTD的内容还要多。 所以目前也没有真正意义上的替代DTD 约束文档： &lt;!-- xmlns : xml namespace : 名称空间 / 命名空间 targetNamespace : 目标名称空间 。 下面定义的那些元素都与这个名称空间绑定上。 elementFormDefault ： 元素的格式化情况。 --&gt; &lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.itheima.com/teacher&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;element name=&quot;teachers&quot;&gt; &lt;complexType&gt; &lt;sequence maxOccurs=&quot;unbounded&quot;&gt; &lt;!-- 这是一个复杂元素 --&gt; &lt;element name=&quot;teacher&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 以下两个是简单元素 --&gt; &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;age&quot; type=&quot;int&quot;&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/schema&gt; 实例文档： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- xmlns:xsi : 这里必须是这样的写法，也就是这个值已经固定了。 xmlns : 这里是名称空间，也固定了，写的是schema里面的顶部目标名称空间 xsi:schemaLocation : 有两段： 前半段是名称空间，也是目标空间的值 ， 后面是约束文档的路径。 --&gt; &lt;teachers xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itheima.com/teacher&quot; xsi:schemaLocation=&quot;http://www.itheima.com/teacher teacher.xsd&quot; &gt; &lt;teacher&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;19&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;/teachers&gt; 名称空间的作用一个xml如果想指定它的约束规则， 假设使用的是DTD ，那么这个xml只能指定一个DTD ， 不能指定多个DTD 。 但是如果一个xml的约束是定义在schema里面，并且是多个schema，那么是可以的。简单的说： 一个xml 可以引用多个schema约束。 但是只能引用一个DTD约束。 名称空间的作用就是在 写元素的时候，可以指定该元素使用的是哪一套约束规则。 默认情况下 ，如果只有一套规则，那么都可以这么写 &lt;name&gt;张三&lt;/name&gt; &lt;aa:name&gt;&lt;/aa:name&gt; &lt;bb:name&gt;&lt;/bb:name&gt; 程序架构网页游戏 C/S(client/server) QQ 微信 LOL 优点： 有一部分代码写在客户端， 用户体验比较好。 缺点： 服务器更新，客户端也要随着更新。 占用资源大。 B/S(browser/server) 网页游戏 ， WebQQ … 优点： 客户端只要有浏览器就可以了。 占用资源小， 不用更新。 缺点： 用户体验不佳。 服务器 其实服务器就是一台电脑。 配置比一般的要好。 Web服务器软件 客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。处理客户端的请求， 返回资源 | 信息 Web应用 需要服务器支撑。 index.html Tomcat apache WebLogic BEA Websphere IBM IIS 微软 Tomcat安装 直接解压 ，然后找到bin/startup.bat 可以安装 启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到内容 就表明成功了。 如果双击了startup.bat, 看到一闪而过的情形，一般都是 JDK的环境变量没有配置。 Tomcat目录介绍bin## &gt; 包含了一些jar , bat文件 。 startup.bat conf##​ tomcat的配置 server.xml web.xml lib tomcat运行所需的jar文件 logs 运行的日志文件 temp 临时文件 webapps## 发布到tomcat服务器上的项目，就存放在这个目录。 work(目前不用管) jsp翻译成class文件存放地 ​ 如何把一个项目发布到tomcat中 需求： 如何能让其他的电脑访问我这台电脑上的资源 。 stu.xml localhost : 本机地址 1. 拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问： http://localhost:8080/stu.xml * 在webaps下面新建一个文件夹xml , 然后拷贝文件放置到这个文件夹中 ​ http://localhost:8080/xml/stu.xml http://localhost:8080 ： 其实对应的是到webapps/root http://localhost:8080/xml/ : 对应是 webapps/xml 使用IP地址访问： http://192.168.37.48:8080/xml/stu.xml 2. 配置虚拟路径使用localhost：8080 打开tomcat首页， 在左侧找到tomcat的文档入口， 点击进去后， 在左侧接着找到 Context入口，点击进入。 http://localhost:8080/docs/config/context.html 在conf/server.xml 找到host元素节点。 加入以下内容。 &lt;!-- docBase ： 项目的路径地址 如： D:\\xml02\\person.xml path : 对应的虚拟路径 一定要以/打头。 对应的访问方式为： http://localhost:8080/a/person.xml --&gt; &lt;Context docBase=&quot;D:\\xml02&quot; path=&quot;/a&quot;&gt;&lt;/Context&gt; 在浏览器地址栏上输入： http://localhost:8080/a/person.xml 3. 配置虚拟路径 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字可以自己定义。 person.xml 在这个文件里面写入以下内容 &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; &lt;Context docBase=&quot;D:\\xml02&quot;&gt;&lt;/Context&gt; 在浏览器上面访问 http://localhost:8080/person/xml的名字即可 给Eclipse配置Tomcat 在server里面 右键新建一个服务器， 选择到apache分类， 找到对应的tomcat版本， 接着一步一步配置即可。 配置完毕后， 在server 里面， 右键刚才的服务器，然后open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation… 创建web工程， 在WebContent下定义html文件， 右键工程， run as server 总结：xml 1. 会定义xml 2. 会解析xml dom4j 基本解析 Xpath手法 tomcat 1. 会安装 ，会启动 ， 会访问。 2. 会设置虚拟路径 3. 给eclipse配置tomcat ​","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://yoursite.com/categories/Java-Web/"}],"tags":[{"name":"java web","slug":"java-web","permalink":"http://yoursite.com/tags/java-web/"}]},{"title":"jsp中加入css和js","slug":"jsp中加入css样式","date":"2019-04-06T01:47:22.000Z","updated":"2019-04-27T12:27:24.000Z","comments":true,"path":"2019/04/06/jsp中加入css样式/","link":"","permalink":"http://yoursite.com/2019/04/06/jsp中加入css样式/","excerpt":"1、 外部样式当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用&lt;link&gt;标签链接到样式表。&lt;link&gt;标签在（文档的）头部：","text":"1、 外部样式当样式需要应用于很多页面时，外部样式表将是理想的选择。在使用外部样式表的情况下，你可以通过改变一个文件来改变整个站点的外观。每个页面使用&lt;link&gt;标签链接到样式表。&lt;link&gt;标签在（文档的）头部： 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"path/myCss.css\"/&gt;&lt;/head&gt; 2、内部样式当单个文档需要特殊的样式时，就应该使用内部样式表。可以使用&lt;style&gt;标签在文档头部定义内部样式表。12345&lt;head&gt;&lt;style type=\"text/css\"&gt;样式&lt;/style&gt;&lt;/head&gt; 3、内联样式当样式仅需要在一个元素上应用一次时, 要使用内联样式，你需要在相关的标签内使用样式（style）属性。Style属性可以包含任何CSS属性。由于要将表现和内容混杂在一起，内联样式会损失掉样式表的许多优势。请慎用这种方法&lt;div style=&quot;width:100px&quot;&gt;&lt;/div&gt; 内联样式的优先级最高，其次是内部样式，外部样式的优先级是最低的。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://yoursite.com/categories/Java-Web/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"Item “xxx” is used by macOS and cannot be opened.","slug":"Item-“xxx”-is-used-by-macOS-and-cannot-be-opened","date":"2019-04-05T04:27:43.000Z","updated":"2019-04-26T07:39:15.000Z","comments":true,"path":"2019/04/05/Item-“xxx”-is-used-by-macOS-and-cannot-be-opened/","link":"","permalink":"http://yoursite.com/2019/04/05/Item-“xxx”-is-used-by-macOS-and-cannot-be-opened/","excerpt":"问题描述Item “xxx” is used by macOS and cannot be opened. 问题原因macOS 默认挂载 ntfs 是只读的，当然，我们有办法使用命令行重新挂载它来变成可读写。不过这容易造成 ntfs 权限错误，结果就是插到另一台电脑上的时候，这个文件可能变成灰色。","text":"问题描述Item “xxx” is used by macOS and cannot be opened. 问题原因macOS 默认挂载 ntfs 是只读的，当然，我们有办法使用命令行重新挂载它来变成可读写。不过这容易造成 ntfs 权限错误，结果就是插到另一台电脑上的时候，这个文件可能变成灰色。 使用 xcode-select –install 来安装命令行工具，安装完成后，我们可以使用下面的命令来查看这个文件的属性：1234567GetFileInfo a.zip file: &quot;filename&quot; type: &quot;brok&quot;creator: &quot;MACS&quot;attributes: avbstclinmedzcreated: 02/23/2019 20:16:52modified: 03/16/2019 09:48:28 解决办法SetFile -c &quot;&quot; -t &quot;&quot; a.zip ReferenceMac OS X – Problems with file permission into NTFS usb drive","categories":[{"name":"Mac系列","slug":"Mac系列","permalink":"http://yoursite.com/categories/Mac系列/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}]},{"title":"Java Arraylist","slug":"Java-Arraylist","date":"2019-04-03T06:20:25.000Z","updated":"2019-04-27T12:25:58.000Z","comments":true,"path":"2019/04/03/Java-Arraylist/","link":"","permalink":"http://yoursite.com/2019/04/03/Java-Arraylist/","excerpt":"Arraylist定义public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 其底层数据结构为数组，实现了 List, RandomAccess, Cloneable, java.io.Serializable","text":"Arraylist定义public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 其底层数据结构为数组，实现了 List, RandomAccess, Cloneable, java.io.Serializable RandomAccess : 快速访问能力，以O(1)访问数组下标。 占据一块连续的内存空间，空间效率不高，内存连续，读写效率高。 属性1234// 保存ArrayList中数据的数组private transient Object[] elementData;// ArrayList中实际数据的数量private int size; elementData是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity)来执行它的初始容量为initialCapacity；如果通过不含参数的构造函数ArrayList()来创建ArrayList，则elementData的容量默认是10。elementData数组的大小会根据ArrayList容量的增长而动态的增长，具体的增长方式，请参考源码分析中的ensureCapacity()函数。 size 则是动态数组的实际大小。 ArrayList扩容原理源码中指定ArrayList的默认初始大小为10的数组，长度为10的Object数组很容易就装满了，如果增加的元素个数超过了10个，那么ArrayList底层会新生成一个数组，长度为原来数组的1.5倍+1，然后将原数组的内容复制到新数组中，并且后续增加的内容都会放到新数组当中，当新数组无法容纳增加的元素时，重复该过程。下图可以看到ArrayList扩容过程 ArrayList安全性因为ArrayList是线程不安全的，ArrayList的操作并非是原子性的，通读ArrayList代码并没有实现线程同步机制的加锁约束。ArrayList添加一个元素的时候，需要两个步骤： Items[Size]的位置存放此元素。 增大Size的值。在单线程运行的情况，这两个步骤是顺序执行的，互相不会影响。但是如果有两个线程去操作。 线程A在0的位置赋了一个值，然后停下来。 B线程ArrayList 0的位置又赋了一个值。其实是重复在一个位置赋值，然后回到A线程，执行Size增加，也就是ArrayList的大小增加了，原来Size是1，现在变成2，然后停下来继续执行线程B，又增加了一个空间位置，size大小就变成了3，结果就是0的位置有值，1和2的索引位置都没有值实际大小是3，跟想要的结果0和1赋不同的值，结果不对。 解决方法借助 Collections.synchronizedList，可以把ArrayList转换为线程安全的List。 与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过工具类Collections转换为线程安全的 123456789101112import java.util.ArrayList;import java.util.Collections;import java.util.List;public class TestThread &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; list2 = Collections.synchronizedList(list1); &#125; &#125; List&lt;Hero&gt; heros = (List&lt;Hero&gt;) Collections.synchronizedList(new LinkedList&lt;Hero&gt;()); ArrayList和LinkedList的区别 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构： Arraylist 底层使用的是Object数组； LinkedList 底层使用的是双向链表数据结构（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别：）； 详细可阅读JDK1.7-LinkedList循环链表优化 插入和删除是否受元素位置的影响： 3.1 ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e) 方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 3.2 LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问， ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index) 方法)。 内存空间占用： ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间. LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据). ####ArrayList和Vector的区别 Vector和ArrayList几乎是完全相同的,唯一的区别在于Vector是同步类(synchronized)，属于强同步类。因此开销就比ArrayList要大，访问要慢。正常情况下,大多数的Java程序员使用ArrayList而不是Vector,因为同步完全可以由程序员自己来控制。 Vector每次扩容请求其大小的2倍空间，而ArrayList是1.5倍。 Vector还有一个子类Stack. 常见问题 ReferenceJava集合干货系列-（一）ArrayList源码解析Java集合中的ArrayList","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Linux Command 速查","slug":"Linux-Command-速查","date":"2019-04-03T06:05:32.000Z","updated":"2019-04-26T07:41:15.000Z","comments":true,"path":"2019/04/03/Linux-Command-速查/","link":"","permalink":"http://yoursite.com/2019/04/03/Linux-Command-速查/","excerpt":"常用指令","text":"常用指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445ls 显示文件或目录 -l 列出文件详细信息l(list) -a 列出当前目录下所有文件及目录，包括隐藏的a(all)mkdir 创建目录 -p 创建目录，若无父目录，则创建p(parent)cd 切换目录touch 创建空文件echo 创建带有内容的文件。cat 查看文件内容cp 拷贝mv 移动或重命名rm 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除find 在文件系统中搜索某文件wc 统计文本中行数、字数、字符数grep 在文本文件中查找某个字符串rmdir 删除空目录tree 树形结构显示目录，需要安装tree包pwd 显示当前目录ln 创建链接文件more、less 分页显示文本文件内容head、tail 显示文件头、尾内容 压缩命令1234567891011121314151617181920212223242526bzip2：tar: 打包压缩 -c 归档文件 -x 压缩文件 -z gzip压缩文件 -j bzip2压缩文件 -v 显示压缩或解压缩过程 v(view) -f 使用档名例：tar -cvf /home/abc.tar /home/abc 只打包，不压缩tar -zcvf /home/abc.tar.gz /home/abc 打包，并用gzip压缩tar -jcvf /home/abc.tar.bz2 /home/abc 打包，并用bzip2压缩当然，如果想解压缩，就直接替换上面的命令 tar -cvf / tar -zcvf / tar -jcvf 中的“ Vim使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。命令模式下：:q 退出:q! 强制退出:wq 保存并退出:set number 显示行号:set nonumber 隐藏行号/apache 在文档中查找apache 按n跳到下一个，shift+n上一个插入模式下：100 dd 删除100行10 yy p 复制10行 p 粘贴h 左移一个字符k 上移一个字符j 下移一个字符w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。b 向后移动一个单词 2b 向后移动2个单词e，同w，只不过是光标停在单词尾部ge，同b，光标停在单词尾部。gg 移动到文件头。 = [[G（shift + g） 移动到文件尾。 = ]]Ctrl + e 向下滚动一行Ctrl + y 向上滚动一行Ctrl + d 向下滚动半屏Ctrl + u 向上滚动半屏Ctrl + f 向下滚动一屏Ctrl + b 向上滚动一屏 用户及用户组管理12345678910111213141516171819202122232425262728293031323334353637383940414243/etc/passwd 存储用户账号/etc/group 存储组账号/etc/shadow 存储用户账号的密码/etc/gshadow 存储用户组账号的密码useradd 用户名userdel 用户名adduser 用户名groupadd 组名groupdel 组名passwd root 给root设置密码su rootsu - root/etc/profile 系统环境变量bash_profile 用户环境变量.bashrc 用户环境变量su user 切换用户，加载配置文件.bashrcsu - user 切换用户，加载配置文件/etc/profile ，加载bash_profile更改文件的用户及用户组sudo chown [-R] owner[:group] &#123;File|Directory&#125;例如：还以jdk-7u21-linux-i586.tar.gz为例。属于用户hadoop，组hadoop要想切换此文件所属的用户及组。可以使用命令。sudo chown root:root jdk-7u21-linux-i586.tar.gz 显示消耗内存最多的10个进程ps aux | sort -nk +4 | tail 实时查看目录下最新改动过的文件watch -d -n 1 &#39;df; ls -FlAt /path&#39; 查看端口占用netstat -tulnp ReferenceLinux 命令速查","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"ERP缩写释义","slug":"ERP缩写释义","date":"2019-04-03T06:00:43.000Z","updated":"2019-04-27T12:25:19.000Z","comments":true,"path":"2019/04/03/ERP缩写释义/","link":"","permalink":"http://yoursite.com/2019/04/03/ERP缩写释义/","excerpt":"常用名词缩写","text":"常用名词缩写 ATO = assemble to Order 按订单装配PLM = Product Lifecycle ManagementEDM = Engineering Data Mangement ASCP = Advanced Supply Chain PlanningHLS = High Level SchedulerSCO = Supply Chain OptimizerMBP = Memory Based Planner BOM = Bill of Material 物料清单 ODS = Operational Data StoreADS = Applications Data StorePDS = Planning Data Store MOS = My Oracle SupportTAR = Technical Assistance RequestSR = Support Request ARU = Automated Release UpdatesKPIs = Key Performance IndicatorsAPS = Advanced Planning Suite WIP = work in process 半制品，在制品ATO = assemble to Order 按订单装配PTO = Pick to Order 按订单拣料 PO = purchasing Order 采购订单purchasing document = 采购单据ASL = Approved Supplier List MDS = Master Demand Schedule 需求计划 PTF = Planning Time Fence 计划时界ASN = Advanced Shipment NoticesASBN = Advanced Shipment Billing Notices The manufacturing and distribution plan types: MPP = Master Production Plans MPS = Master Production Schedules 主生产计划 MRP = Material Requirements Plans 物料需求计划 DRP = Distribution Plans PIP = Planned Inventory Points 计划库存点UOM = Unit of measure 测量单位 概念： Value Engineering = 工程经济学，最经济管理法Procure to Pay = 采购到付款 Blind Receipt = 盲接收（是指在“接收”窗口中不显示预计接收数量（数量全部为0），旨在要求接收人员清点接收行上的所有物料数量）Cascade Receipt = 级联接收Express Receipt = 快速接收Substitute Receipt = 替代接收 on-hand Qty = 现有量Receiving Transaction = 交付Assignment Set = 分配集 Purchase Order and Types： Blanket Purchase Agreement = BPA 一揽子采购协议是一种为降低采购成本,与供应商签订的中长期采购协议。一次签订,多次要货 Contract Purchase Agreement 和约采购 Planned Purchase Order Standard Purchase Order business group: 企业集团Set of books: [财]成套账簿accounting entity： 会计legal entity: 法人Operating unit： 经营机构;操作单位inventory organization： 库存组织Subinventory： 子库存Inventory transactions： 库存模块； 存货处理； 存货交易Time Fence 时界; 时间栏; 时间栅栏Header Information: 标题信息line Information: 相关信息？链接资讯 Oracle Engineering BOM = 工程资料管理系统Oracle Work in Process = 生管管理系统Oracle Cost Management = 成本管理系统 ATP = Available to Promise（有存货才保证）： 指基于预定义的现有与计划供给情况对交货做出承诺的能力。CTP = Capable to Promise（有生产能力才保证）： 指确定部件物料和资源的可用性以满足非计划需求的附加能力。CTD = Capable to Deliver （有交货能力）：指考虑转移提前期 以满足客户交货的需要。 FOB = free on board 离岸价格； 船上交货； 离岸价； 目的地交货Freight On Board (FOB) Shipping: 运输sales order: 销售定单 3 types of Sales OrdersStandard (can only be used for ordering material) Mixed (Can be used for ordering material and also returning the material )**Return (Can be used only for returning material) ORACLE： OBI = Oracle Base ImageOIM = Oracle Identify ManagementMDM = Mobile Device ManagementSSO = Single Sign OnOIM = Oracle Identity Management RDBMS = Relational Database Management SystemERP = Enterprise Resource Planning 企业资源计划系统CRM = Customer Relationship ManagementBIS = Business Intelligent system","categories":[{"name":"Oracle Tools","slug":"Oracle-Tools","permalink":"http://yoursite.com/categories/Oracle-Tools/"}],"tags":[]},{"title":"ADE Commands","slug":"ADE-Commands","date":"2019-04-03T05:55:55.000Z","updated":"2019-04-27T12:24:49.000Z","comments":true,"path":"2019/04/03/ADE-Commands/","link":"","permalink":"http://yoursite.com/2019/04/03/ADE-Commands/","excerpt":"常用的ADE Commands:","text":"常用的ADE Commands: * cd $ADE_VIEW_NAME * cd $ADE_VIEW_ROOT * ade okinit * setenv ADE_SITE ade_fusion_slc * ade createview -series &lt;Series Name&gt; (-label &lt;label name&gt; or -latest) &lt;view name/workspace name on local&gt; -------&gt; Create workspace and checkout * ade createview scm_orchinfra_view -series FUSIONAPPS_PT.INTSCMC_LINUX.X64 -latest * ade useview &lt;view name&gt; -------&gt;Start using the view/workspace * jdev &amp; -------&gt;open Jdeveloper with the view created in step 2. we need to import the code manually. * ade begintrans &lt;bug number&gt; -no_restore -------&gt;/ create trans file on the view. It will take time so we will start jdev. * ade ci &lt;filename&gt; * ade ci -all or ade ciall -------&gt;to checkin all files * * ade begintrans ranathi_scmc_trnx -------&gt; Begins transaction * ade savetrans &lt;trans_name&gt; -------&gt;/ after this others can view the trans file. * ade describetrans &lt;trans_name&gt; -------&gt; it will tell how many files we changed . * ade renametrans -bug &lt;bug number&gt; ------&gt; change bug number * ade destroytrans -force &lt;trans_name&gt; -------&gt;local changes will be destroyed and trans file will be deleted. * ade tkreview &lt;trans_name&gt; -------&gt;To see a particular transaction for changes * ade tkreview -view -------&gt;To see a particular transaction along with the file that are not checked-in. * ade tkvtree &lt;file&gt; * ade lsco * ade unco &lt;filename&gt; / ade unco -all -------&gt;the changes will be unbranched from trans file, but changes will be still there on our local. To branch again change the file again and it will be associated to transaction. * ade fetchtrans(get saved trans) /grabtrans(get ci transactions) &lt;trans_name&gt; -------&gt; to merge other person trans file to our local. * ade grabtrans &lt;trans_name&gt; * ade sharetrans &lt;trans_name&gt; ade unbranch &lt;fullpath&gt; ------&gt; rollback the checkin, or cancel the checked in files from txn * ade showseries | grep SCMC -------&gt; Shows all serires * ade lsviews -------&gt; To view all our views * vncconfig &amp; -------&gt; To copy from windows to VM * ade lshistory &lt;filename&gt; |grep Merges ------&gt; To get History of file * ade showlabels -series FUSIONAPPS_11.1.1.5.1_LINUX.X64 ------&gt; Shows all labels in a series * ade exec /usr/local/nde/ade/util/adhoc_query_scripts/list_merges_to_branch.pl -p FUSIONAPPS -b st_fusionapps_11.1.1.5.1 -d 30 -sort_by // Get transactions of past 30 days * ade mkelem &lt;file-name&gt; ----&gt; To add file to branch * ade rm &lt;file-name&gt; * ade pwv ------&gt; Display info for the named view; defaults to the current view * ade pwd ------&gt; displays view-relative path, otherwise displays absolute path. * ade destroyview &lt;view name&gt;","categories":[{"name":"Oracle Tools","slug":"Oracle-Tools","permalink":"http://yoursite.com/categories/Oracle-Tools/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":" Java 集合 - Collection","slug":"Java-容器","date":"2019-04-02T08:06:41.000Z","updated":"2019-04-27T12:26:33.000Z","comments":true,"path":"2019/04/02/Java-容器/","link":"","permalink":"http://yoursite.com/2019/04/02/Java-容器/","excerpt":"","text":"ImplementationsHash TableResizable ArrayBalanced TreeLinked ListHash Table + Linked ListInterfacesSetHashSetTreeSetLinkedHashSetListArrayListLinkedListDequeArrayDequeLinkedListMapHashMapTreeMapLinkedHashMap 1.容器类接口和抽象容器类1.1 说明 容器接口是容器的基础。使用接口可以将容器的实现与容器接口分开，因而可以使用相同的方法访问容器而不需关心容器具体的数据结构。 同理，Iterator接口也使用户能够使用相同的方法访问不同的容器类。 1.2 容器接口（Collection，Map，Iterator）1）collection接口1234567* boolean add(Object obj): 添加对象，集合发生变化则返回true* Iterator iterator()：返回Iterator接口的对象* int size()* boolean isEmpty()* boolean contains(Object obj)* void clear()* &lt;T&gt; T[] toArray(T[] a) 2）Map接口（存放键值对，Map中的值也可以是一个容器）123456* Object get（Object key）* Object put（Object key, Object value）* Set keySet() : returns the keys set Set&lt;K&gt; keySet()* Set entrySet(): returns mappings set Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()* containsKey()* containsValue() 3）Iterator接口123* Object next()* boolean hasNext()* void remove() 方法1.使用抽象编程思想，创建时使用父类引用指向子类对象，返回时返回抽象接口 2.如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。 3.如果程序在单线程环境中使用非同步的类，其效率较高 4.可以使用Collections 工具类中 unmodifiableList/unmodifiableMap/unmodifiableSet/unmodifiableSortedMap/unmodifiableSortedSet 等创建不能修改的List,Map,List等 5.可以使用Collections工具类中Collections.synchronizedList(new ArrayList())等实现同步 6.可以使用Arrays.equal()判断两个数组是否相等","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":" Java Transient 关键字","slug":"Java-Transient-关键字","date":"2019-04-02T07:29:29.000Z","updated":"2019-04-27T12:26:18.000Z","comments":true,"path":"2019/04/02/Java-Transient-关键字/","link":"","permalink":"http://yoursite.com/2019/04/02/Java-Transient-关键字/","excerpt":"1. transient的作用及使用方法一个对象只要实现了Serilizable接口，这个对象就可以被序列化.只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。","text":"1. transient的作用及使用方法一个对象只要实现了Serilizable接口，这个对象就可以被序列化.只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 类的有些属性需要序列化，而其他属性不需要被序列化，为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; private String username; private transient String passwd;&#125;public static void main(String[] args) &#123; User user = new User(); user.setUsername(\"test\"); user.setPasswd(\"123456\"); System.out.println(\"Before Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.err.println(\"password: \" + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream(\"C:/user.txt\")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream( \"C:/user.txt\")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println(\"After Serializable: \"); System.out.println(\"username: \" + user.getUsername()); System.err.println(\"password: \" + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; Outout: Before Serializable:username: testpassword: 123456 After Serializable:username: testpassword: null 2. transient使用 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":" Java Final 关键字","slug":"Java-Final-关键字","date":"2019-04-02T07:06:42.000Z","updated":"2019-04-27T12:26:04.000Z","comments":true,"path":"2019/04/02/Java-Final-关键字/","link":"","permalink":"http://yoursite.com/2019/04/02/Java-Final-关键字/","excerpt":"应用于： 变量 方法 类","text":"应用于： 变量 方法 类 变量Final 声明的叫做final变量。经常和static一起使用。 1public static final String LOAN = ‘loan’; 方法方法加上final关键字，表明不可以被子类重写。———— 如果一个方法非常完善，不需要改变，声明为final。final方法比非final方法快———— 因为编译的时候已经静态绑定了，不需要再运行时动态绑定。 123public final String getName()&#123; return \"cheap personal loan\"; //compilation error: overridden method is final &#125; 类final类是完整的，不能被继承——— String类，Integer类 以及其他包装类。 1234567final class PersonalLoan&#123; &#125; class CheapPersonalLoan extends PersonalLoan&#123; //compilation error: cannot inherit from final class &#125; 优点： 提高性能 ——— JVM 和 java 应用会缓存很多final变量 多线程共享，不需要额外开销。 JVM对方法、变量进行优化。 Tips: final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。 在匿名类中所有变量都必须是final变量。 final关键字不同于finally关键字，后者用于异常处理。 final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。 接口中声明的所有变量本身是final的。 final和abstract这两个关键字是反相关的，final类就不可能是abstract的。 final方法在编译阶段绑定，称为静态绑定(static binding)。 对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。譬如： 1234private final List Loans = new ArrayList();list.add(“home loan”); //validlist.add(\"personal loan\"); //validloans = new Vector(); //not valid 用途 Java在运行的时候保存了一个String pool，只有是不可变的，这个pool才有可能实现。 安全问题，密码，数据库用户名，以字符串获得连接。 多线程安全，同一个字符串实例可以被多个线程共享。 类加载器用字符串，也是为了安全性。 Hashmap中使用字符串，速度快。 创建一个不可变类 将类声明为final，所以它不能被继承 将所有的成员声明为私有的，这样就不允许直接访问这些成员 对变量不要提供setter方法 将所有可变的成员声明为final，这样只能对它们赋值一次 通过构造器初始化所有成员，进行深拷贝(deep copy) 在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝 Related Links如何使用建造者模式(Builder Pattern)创建不可变类Final of Java，这一篇差不多了","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":" Java Static 关键字","slug":"Java-Static-关键字","date":"2019-04-02T06:52:53.000Z","updated":"2019-04-27T12:26:12.000Z","comments":true,"path":"2019/04/02/Java-Static-关键字/","link":"","permalink":"http://yoursite.com/2019/04/02/Java-Static-关键字/","excerpt":"变量和方法静态变量，被队友对象共享，内存中只有一个副本，仅仅在类加载的时候被初始化。是属于这个类的，不属于某个变量，被类中所有变量共享. 如果方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。","text":"变量和方法静态变量，被队友对象共享，内存中只有一个副本，仅仅在类加载的时候被初始化。是属于这个类的，不属于某个变量，被类中所有变量共享. 如果方法执行的操作不依赖于其类的各个变量和方法，请将其设置为静态（这将使程序的占用空间更小）。 否则，它应该是非静态的。静态方法在类加载的时候就存在了，它不依赖于任何实例，所以静态方法必须有实现，也就是说它不能是抽象方法（abstract）。 代码块静态语句块在类初始化时运行一次。 内部类内部类的一种，静态内部类不依赖外部类，且不能访问外部类的非静态的变量和方法。延迟初始化，线程安全。 示例12345678910111213141516public class Singleton &#123; 声明为 private 避免调用默认构造方法创建对象 private Singleton() &#123; &#125; 声明为 private 表明静态内部该类只能在该 Singleton 类中被访问 private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; public static Singleton getUniqueInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 当 Singleton 类加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 getUniqueInstance() 方法从而触发 SingletonHolder.INSTANCE 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。 静态代码块和非静态代码块相同点：都是在JVM加载类时且在构造方法执行之前执行，在类中都可以定义多个，定义多个时按定义的顺序执行，一般在代码块中对一些static变量进行赋值。不同点： 静态代码块在非静态代码块之前执行(静态代码块—非静态代码块—构造方法)。静态代码块只在第一次new执行一次，之后不再执行，而非静态代码块在每new一次就执行一次。 非静态代码块可在普通方法中定义(不过作用不大)；而静态代码块不行。","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java 深拷贝与浅拷贝","slug":"Java-深拷贝与浅拷贝","date":"2019-04-02T02:54:07.000Z","updated":"2019-04-27T12:26:40.000Z","comments":true,"path":"2019/04/02/Java-深拷贝与浅拷贝/","link":"","permalink":"http://yoursite.com/2019/04/02/Java-深拷贝与浅拷贝/","excerpt":"前言浅拷贝和深拷贝都是针对一个已有对象的操作。 在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象 这个引用数据类型。而一般使用 『 = 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。","text":"前言浅拷贝和深拷贝都是针对一个已有对象的操作。 在 Java 中，除了基本数据类型（元类型）之外，还存在 类的实例对象 这个引用数据类型。而一般使用 『 = 』号做赋值操作的时候。对于基本数据类型，实际上是拷贝的它的值，但是对于对象而言，其实赋值的只是这个对象的引用，将原对象的引用传递过去，他们实际上还是指向的同一个对象。 而浅拷贝和深拷贝就是在这个基础之上做的区分，如果在拷贝这个对象的时候，只对基本数据类型进行了拷贝，而对引用数据类型只是进行了引用的传递，而没有真实的创建一个新的对象，则认为是浅拷贝。反之，在对引用数据类型进行拷贝的时候，创建了一个新的对象，并且复制其内的成员变量，则认为是深拷贝。 所谓的浅拷贝和深拷贝，只是在拷贝对象的时候，对类的实例对象这种引用数据类型的不同操作而已。 浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。 深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。 java clone()方法Object 上的 clone() 方法在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中使用它。而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。 clone 规则 基本类型 如果变量是基本类型，则拷贝其值，比如int、float等。 对象 如果变量是一个实例对象，则拷贝其地址引用，也就是说新对象和原来对象是共用实例变量的。 String字符串 若变量为String字符串，则拷贝其地址引用。但是在修改时，它会从字符串池中重新生成一个新的字符串，原有的对象保持不变。 clone 步骤 实现Cloneable接口 重载Object类中的clone()方法，重载时需定义为public 在重载方法中，调用super.clone() 浅拷贝首先创建一个 class 为 FatherClass ，对其实现 Cloneable 接口，并且重写 clone() 方法。、12345678910111213141516171819public class father implements Cloneable&#123; public child son; @Override public Object clone() throws CloneNotSupportedException &#123; father father = (father)super.clone(); //这里注释掉就是浅克隆，否则就是深克隆 father.son = (child)son.clone(); return father; &#125; &#125;public class child implements Cloneable&#123; public Object clone() throws CloneNotSupportedException &#123; return (child)super.clone(); &#125;&#125; 深拷贝 序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。 继续利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。 总结实则浅拷贝和深拷贝只是相对的，如果一个对象内部只有基本数据类型，那用 clone() 方法获取到的就是这个对象的深拷贝，而如果其内部还有引用数据类型，那用 clone() 方法就是一次浅拷贝的操作。","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JsonUtils","slug":"JsonUtils","date":"2019-04-02T02:38:23.000Z","updated":"2019-04-27T12:27:14.000Z","comments":true,"path":"2019/04/02/JsonUtils/","link":"","permalink":"http://yoursite.com/2019/04/02/JsonUtils/","excerpt":"前言项目中经常会有String转Object以及Object转Json字符串的需求，故封装一个常用Json工具类","text":"前言项目中经常会有String转Object以及Object转Json字符串的需求，故封装一个常用Json工具类 Maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt;&lt;/dependency&gt; jar包下载Jar包下载地址 工具类代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136import org.apache.commons.lang3.StringUtils;import org.codehaus.jackson.map.DeserializationConfig;import org.codehaus.jackson.map.ObjectMapper;import org.codehaus.jackson.map.SerializationConfig;import org.codehaus.jackson.map.annotate.JsonSerialize.Inclusion;import org.codehaus.jackson.type.JavaType;import org.codehaus.jackson.type.TypeReference;import java.io.IOException;import java.text.SimpleDateFormat;/** * Jackson工具类 * * @author suddev * @create 2017-11-25 2:18 PM **/public class JsonUtil1 &#123; private static ObjectMapper objectMapper = new ObjectMapper(); static &#123; // 对象字段全部列入 objectMapper.setSerializationInclusion(Inclusion.NON_DEFAULT); // 取消默认转换timestamps形式 objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS,false); // 忽略空bean转json的错误 objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS,false); // 统一日期格式yyyy-MM-dd HH:mm:ss objectMapper.setDateFormat(new SimpleDateFormat(DateTimeUtil.STANDARD_FORMAT)); // 忽略在json字符串中存在,但是在java对象中不存在对应属性的情况 objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES,false); &#125; /** * Object转json字符串 * @param obj * @param &lt;T&gt; * @return */ public static &lt;T&gt; String obj2String(T obj)&#123; if (obj == null)&#123; return null; &#125; try &#123; return obj instanceof String ? (String) obj : objectMapper.writeValueAsString(obj); &#125; catch (Exception e) &#123; System.out.println(\"Parse object to String error\"); e.printStackTrace(); return null; &#125; &#125; /** * Object转json字符串并格式化美化 * @param obj * @param &lt;T&gt; * @return */ public static &lt;T&gt; String obj2StringPretty(T obj)&#123; if (obj == null)&#123; return null; &#125; try &#123; return obj instanceof String ? (String) obj : objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); &#125; catch (Exception e) &#123; System.out.println(\"Parse object to String error\"); e.printStackTrace(); return null; &#125; &#125; /** * string转object * @param str json字符串 * @param clazz 被转对象class * @param &lt;T&gt; * @return */ public static &lt;T&gt; T string2Obj(String str,Class&lt;T&gt; clazz)&#123; if (StringUtils.isEmpty(str) || clazz == null)&#123; return null; &#125; try &#123; return clazz.equals(String.class)? (T) str :objectMapper.readValue(str,clazz); &#125; catch (IOException e) &#123; System.out.println(\"Parse String to Object error\"); e.printStackTrace(); return null; &#125; &#125; /** * string转object * @param str json字符串 * @param typeReference 被转对象引用类型 * @param &lt;T&gt; * @return */ public static &lt;T&gt; T string2Obj(String str, TypeReference&lt;T&gt; typeReference)&#123; if (StringUtils.isEmpty(str) || typeReference == null)&#123; return null; &#125; try &#123; return (T)(typeReference.getType().equals(String.class)? str :objectMapper.readValue(str,typeReference)); &#125; catch (IOException e) &#123; System.out.println(\"Parse String to Object error\"); e.printStackTrace(); return null; &#125; &#125; /** * string转object 用于转为集合对象 * @param str json字符串 * @param collectionClass 被转集合class * @param elementClasses 被转集合中对象类型class * @param &lt;T&gt; * @return */ public static &lt;T&gt; T string2Obj(String str,Class&lt;?&gt; collectionClass,Class&lt;?&gt;... elementClasses)&#123; JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass,elementClasses); try &#123; return objectMapper.readValue(str,javaType); &#125; catch (IOException e) &#123; System.out.println(\"Parse String to Object error\"); e.printStackTrace(); return null; &#125; &#125;&#125;","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"MD5Utils","slug":"MD5Utils","date":"2019-04-02T01:57:03.000Z","updated":"2019-04-27T12:27:47.000Z","comments":true,"path":"2019/04/02/MD5Utils/","link":"","permalink":"http://yoursite.com/2019/04/02/MD5Utils/","excerpt":"MD5工具类介绍MD5(Message Digest Algorithm)加密算法是不对称的加密算法，因为其实不可逆的，实际上其不能算作加密算法，因为其不可解密。其实现原理是基于Hash算法(简称散列函数)。","text":"MD5工具类介绍MD5(Message Digest Algorithm)加密算法是不对称的加密算法，因为其实不可逆的，实际上其不能算作加密算法，因为其不可解密。其实现原理是基于Hash算法(简称散列函数)。 MD5算法特点1、压缩性:任意长度的数据，算出的MD5值长度都是固定的。2、容易计算:从原数据计算出MD5值很容易(算法简单)3、抗修改性:对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。4、强抗碰撞:已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。5、不可逆计算反推 代码实现12345678910111213141516171819202122232425262728293031323334353637383940import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;public class Md5Utils &#123; /** * 使用md5的算法进行加密 */ public static String md5(String plainText) &#123; byte[] secretBytes = null; try &#123; secretBytes = MessageDigest.getInstance(\"md5\").digest( plainText.getBytes()); &#125; catch (NoSuchAlgorithmException e) &#123; throw new RuntimeException(\"没有md5这个算法！\"); &#125; String md5code = new BigInteger(1, secretBytes).toString(16);// 16进制数字 // 如果生成数字未满32位，需要前面补0 for (int i = 0; i &lt; 32 - md5code.length(); i++) &#123; md5code = \"0\" + md5code; &#125; return md5code; &#125;&#125;","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java 类排序（泛型集合排序）","slug":"Java类排序（泛型集合排序）","date":"2019-04-01T14:01:40.000Z","updated":"2019-04-27T12:26:59.000Z","comments":true,"path":"2019/04/01/Java类排序（泛型集合排序）/","link":"","permalink":"http://yoursite.com/2019/04/01/Java类排序（泛型集合排序）/","excerpt":"Java 类排序（泛型集合排序）","text":"Java 类排序（泛型集合排序） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.text.SimpleDateFormat;public class UserInfo implements java.io.Serializable&#123; private java.lang.Integer userId; private java.lang.String username; private java.util.Date birthDate; private java.lang.Integer age; private SimpleDateFormat formater = new SimpleDateFormat(\"yyyy-MM-dd\"); public UserInfo()&#123;&#125; public UserInfo(java.lang.Integer userId, java.lang.String username, java.util.Date birthDate, java.lang.Integer age)&#123; this.userId = userId; this.username = username; this.birthDate = birthDate; this.age = age; &#125; public void setUserId(java.lang.Integer value) &#123; this.userId = value; &#125; public java.lang.Integer getUserId() &#123; return this.userId; &#125; public void setUsername(java.lang.String value) &#123; this.username = value; &#125; public java.lang.String getUsername() &#123; return this.username; &#125; public void setBirthDate(java.util.Date value) &#123; this.birthDate = value; &#125; public java.util.Date getBirthDate() &#123; return this.birthDate; &#125; public void setBirthDatestr(String value) throws Exception&#123; setBirthDate(formater.parse(value)); &#125; public java.lang.String getBirthDatestr() &#123; return formater.format(getBirthDate()); &#125; public void setAge(java.lang.Integer value) &#123; this.age = value; &#125; public java.lang.Integer getAge() &#123; return this.age; &#125; public String toString() &#123; return new StringBuffer().append(getUserId()).append(\"; \"+getUsername()).append(\"; \"+getBirthDatestr()).append(\"; \"+getAge()).toString(); &#125;&#125; 1234567Collections.sort(list, new Comparator() &#123; public int compare(Object a, Object b) &#123; int one = ((Order)a).getUserId (); int two = ((Order)b).getUserId (); return one- two ; &#125;&#125;); 1234567891011121314151617181920212223242526272829303132import java.util.Collections;import java.util.Comparator;import java.util.List;import java.lang.reflect.Method;import java.lang.reflect.InvocationTargetException;/*** 通用排序*/public class SortList&lt;E&gt;&#123; public void Sort(List&lt;E&gt; list, final String method, final String sort)&#123; Collections.sort(list, new Comparator() &#123; public int compare(Object a, Object b) &#123; int ret = 0; try&#123; Method m1 = ((E)a).getClass().getMethod(method, null); Method m2 = ((E)b).getClass().getMethod(method, null); if(sort != null &amp;&amp; \"desc\".equals(sort))//倒序 ret = m2.invoke(((E)b), null).toString().compareTo(m1.invoke(((E)a), null).toString()); else//正序 ret = m1.invoke(((E)a), null).toString().compareTo(m2.invoke(((E)b), null).toString()); &#125;catch(NoSuchMethodException ne)&#123; System.out.println(ne); &#125;catch(IllegalAccessException ie)&#123; System.out.println(ie); &#125;catch(InvocationTargetException it)&#123; System.out.println(it); &#125; return ret; &#125; &#125;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;import java.util.List;import java.text.SimpleDateFormat;public class Test &#123;public static void main(String[] args)throws Exception&#123; List&lt;UserInfo&gt; list = new ArrayList&lt;UserInfo&gt;(); SimpleDateFormat formater = new SimpleDateFormat(\"yyyy-MM-dd\"); list.add(new UserInfo(3,\"b\",formater.parse(\"1980-12-01\"),11)); list.add(new UserInfo(1,\"c\",formater.parse(\"1980-10-01\"),30)); list.add(new UserInfo(2,\"a\",formater.parse(\"1973-10-01\"),11)); System.out.println(\"-------原来序列-------------------\"); for(UserInfo user : list)&#123; System.out.println(user.toString()); &#125; //调用排序通用类 SortList&lt;UserInfo&gt; sortList = new SortList&lt;UserInfo&gt;();//按userId排序 sortList.Sort(list, \"getUserId\", \"desc\"); System.out.println(\"--------按userId倒序------------------\"); for(UserInfo user : list)&#123; System.out.println(user.toString()); &#125;//按username排序 sortList.Sort(list, \"getUsername\", null); System.out.println(\"---------按username排序-----------------\"); for(UserInfo user : list)&#123; System.out.println(user.toString()); &#125;//按birthDate排序 sortList.Sort(list, \"getBirthDatestr\", null); System.out.println(\"---------按birthDate排序-----------------\"); for(UserInfo user : list)&#123; System.out.println(user.toString()); &#125; &#125;&#125;","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java 泛型","slug":"泛型","date":"2019-04-01T13:59:56.000Z","updated":"2019-04-27T12:28:36.000Z","comments":true,"path":"2019/04/01/泛型/","link":"","permalink":"http://yoursite.com/2019/04/01/泛型/","excerpt":"通俗解释 通俗的讲，泛型就是操作类型的 占位符，即：假设占位符为 T，那么此次声明的数据结构操作的数据类型为T类型。","text":"通俗解释 通俗的讲，泛型就是操作类型的 占位符，即：假设占位符为 T，那么此次声明的数据结构操作的数据类型为T类型。 假定我们有这样一个需求：写一个排序方法，能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，该如何实现？答案是可以使用 Java 泛型。 使用 Java 泛型的概念，我们可以写一个泛型方法来对一个对象数组排序。然后，调用该泛型方法来对整型数组、浮点数数组、字符串数组等进行排序。 泛型方法 你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。 下面是定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的 \\）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明和其他方法一样。注意类型参数 只能代表引用型类型，不能是原始类型 （像 int,double,char 的等）。 1234567891011121314151617181920212223242526272829public class GenericMethodTest&#123; // 泛型方法 printArray public static &lt; E &gt; void printArray( E[] inputArray ) &#123; // 输出数组元素 for ( E element : inputArray )&#123; System.out.printf( \"%s \", element ); &#125; System.out.println(); &#125; public static void main( String args[] ) &#123; // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = &#123; 1, 2, 3, 4, 5 &#125;; Double[] doubleArray = &#123; 1.1, 2.2, 3.3, 4.4 &#125;; Character[] charArray = &#123; 'H', 'E', 'L', 'L', 'O' &#125;; System.out.println( \"整型数组元素为:\" ); printArray( intArray ); // 传递一个整型数组 System.out.println( \"\\n双精度型数组元素为:\" ); printArray( doubleArray ); // 传递一个双精度型数组 System.out.println( \"\\n字符型数组元素为:\" ); printArray( charArray ); // 传递一个字符型数组 &#125; &#125; 泛型类 泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 123456789101112131415161718192021public class Box&lt;T&gt; &#123; private T t; public void add(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125; public static void main(String[] args) &#123; Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;(); Box&lt;String&gt; stringBox = new Box&lt;String&gt;(); integerBox.add(new Integer(10)); stringBox.add(new String(\"菜鸟教程\")); System.out.printf(\"整型值为 :%d\\n\\n\", integerBox.get()); System.out.printf(\"字符串为 :%s\\n\", stringBox.get()); &#125;&#125; 类型通配符 类型通配符一般是使用 ? 代替具体的类型参数。例如 List&lt;?&gt; 在逻辑上是 List&lt;String&gt;，List&lt;Integer&gt; 等所有 List&lt;具体类型实参&gt; 的父类。 类型通配符上限通过形如 List 来定义，如此定义就是通配符泛型值接受 Number 及其下层子类类型。 类型通配符下限通过形如 List&lt;? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如 Objec 类型的实例。 参考资料： Java 泛型，了解这些就够用了。 - 逃离沙漠 - 博客园 【Java心得总结四】Java泛型下——万恶的擦除 - xlturing - 博客园 Java 泛型原理","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java 反射","slug":"反射","date":"2019-04-01T13:58:36.000Z","updated":"2019-04-29T05:54:26.000Z","comments":true,"path":"2019/04/01/反射/","link":"","permalink":"http://yoursite.com/2019/04/01/反射/","excerpt":"概念 运行一个程序需要先将类加载到运行时数据区，同时会将类的结构信息保存到方法区中，同时会在堆区中创建一个特殊的对象，可以使用该对象操作方法区中类的信息，那么这个特殊的对象是什么类型呢？该对象Java提供了Class类型表示。其实每个类只要加载之后都会对应有自己的这个特特殊类对象，可以使用这个特殊类对象操作方法区中的类信息结构，这种方式就是反射机制。","text":"概念 运行一个程序需要先将类加载到运行时数据区，同时会将类的结构信息保存到方法区中，同时会在堆区中创建一个特殊的对象，可以使用该对象操作方法区中类的信息，那么这个特殊的对象是什么类型呢？该对象Java提供了Class类型表示。其实每个类只要加载之后都会对应有自己的这个特特殊类对象，可以使用这个特殊类对象操作方法区中的类信息结构，这种方式就是反射机制。 反射是什么呢？当我们的程序在运行时，需要动态的加载一些类这些类可能之前用不到所以不用加载到 JVM，而是在运行时根据需要才加载，这样的好处对于服务器来说不言而喻。 举个例子我们的项目底层有时是用 mysql，有时用 oracle，需要动态地根据实际情况加载驱动类，这个时候反射就有用了，假设 com.java.dbtest.myqlConnection，com.java.dbtest.oracleConnection 这两个类我们要用，这时候我们的程序就写得比较动态化，通过 Class tc = Class.forName(“com.java.dbtest.TestConnection”); 通过类的全类名让 JVM 在服务器中找到并加载这个类，而如果是 Oracle 则传入的参数就变成另一个了。这时候就可以看到反射的好处了，这个动态性就体现出 Java 的特性了！ 举多个例子，大家如果接触过 spring，会发现当你配置各种各样的 bean 时，是以配置文件的形式配置的，你需要用到哪些 bean 就配哪些，spring 容器就会根据你的需求去动态加载，你的程序就能健壮地运行。 什么是反射 反射 (Reflection) 是 Java 程序开发语言的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。通过 Class 获取 class 信息称之为反射（Reflection） 简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。 程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。 Java 反射框架主要提供以下功能： 1. 在运行时判断任意一个对象所属的类 2. 在运行时构造任意一个类的对象 3. 在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用 private 方法） 4. 在运行时调用任意一个对象的方法 重点：是运行时而不是编译时 主要用途 很多人都认为反射在实际的 Java 开发应用中并不广泛，其实不然。 当我们在使用 IDE （如Eclipse，IDEA）时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射。 反射最重要的用途就是开发各种通用框架 很多框架（比如 Spring ）都是配置化的（比如通过 XML 文件配置 JavaBean,Action 之类的），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。 对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。 获得Class对象 调用运行时类本身的 .class 属性 12Class clazz1 = Person.class;System.out.println(clazz1.getName()); 通过运行时类的对象获取 getClass(); 123Person p = new Person();Class clazz3 = p.getClass();System.out.println(clazz3.getName()); 使用 Class 类的 forName 静态方法 123public static Class&lt;?&gt; forName(String className)// 在JDBC开发中常用此方法加载数据库驱动:Class.forName(driver); （了解）通过类的加载器 ClassLoader 123ClassLoader classLoader = this.getClass().getClassLoader();Class clazz5 = classLoader.loadClass(className);System.out.println(clazz5.getName()); 参考资料： 深入解析Java反射（1） - 基础 | 「浮生若梦」 - sczyh30’s blog 学习java应该如何理解反射？ - 知乎","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java 初始化顺序","slug":"Java初始化顺序","date":"2019-04-01T13:32:23.000Z","updated":"2019-04-27T12:26:47.000Z","comments":true,"path":"2019/04/01/Java初始化顺序/","link":"","permalink":"http://yoursite.com/2019/04/01/Java初始化顺序/","excerpt":"Java程序初始化的顺序是怎么样的 在 Java 语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建象。","text":"Java程序初始化的顺序是怎么样的 在 Java 语言中，当实例化对象时，对象所在类的所有成员变量首先要进行初始化，只有当所有类成员完成初始化后，才会调用对象所在类的构造函数创建象。 初始化一般遵循3个原则： 静态对象（变量）优先于非静态对象（变量）初始化，静态对象（变量）只初始化一次，而非静态对象（变量）可能会初始化多次； 父类优先于子类进行初始化； 按照成员变量的定义顺序进行初始化。 即使变量定义散布于方法定义之中，它们依然在任何方法（包括构造函数）被调用之前先初始化； 加载顺序 父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 实例11234567891011121314151617181920212223242526272829303132class Base &#123; // 1.父类静态代码块 static &#123; System.out.println(\"Base static block!\"); &#125; // 3.父类非静态代码块 &#123; System.out.println(\"Base block\"); &#125; // 4.父类构造器 public Base() &#123; System.out.println(\"Base constructor!\"); &#125;&#125;public class Derived extends Base &#123; // 2.子类静态代码块 static&#123; System.out.println(\"Derived static block!\"); &#125; // 5.子类非静态代码块 &#123; System.out.println(\"Derived block!\"); &#125; // 6.子类构造器 public Derived() &#123; System.out.println(\"Derived constructor!\"); &#125; public static void main(String[] args) &#123; new Derived(); &#125;&#125; 输出：123456Base static block!Derived static block!Base blockBase constructor!Derived block!Derived constructor! 实例2123456789101112131415161718192021222324252627282930313233343536373839404142434445class Log &#123; public staitc String baseFieldInit() &#123; System.out.print(\"Base normal field\"); return \"\"; &#125; public staitc String baseStaticFieldInit() &#123; System.out.print(\"Base static field\"); return \"\"; &#125; public staitc String fieldInit() &#123; System.out.print(\"Normal field\"); return \"\"; &#125; public staitc String staticFieldInit() &#123; System.out.print(\"Static field\"); return \"\"; &#125;class Base &#123; static &#123;System.out.println(\"Base static block 1\");&#125; private static String staticValue=Log.baseStaticFieldInit(); static &#123;System.out.println(\"Base static block 2\");&#125; &#123;System.out.println(\"Base normal block 1\");&#125; private String value=Log.baseFieldInit(); &#123;System.out.println(\"Base normal block 2\");&#125; Base()&#123; System.out.println(\"Base constructor\"); &#125; &#125;public class Derived extends Base&#123; static &#123;System.out.println(\"Static block 1\");&#125; private static String staticValue=Log.staticFieldInit(); static &#123;System.out.println(\"Static block 2\");&#125; &#123;System.out.println(\"Normal block 1\");&#125; private String value=Log.fieldInit(); &#123;System.out.println(\"Normal block 2\");&#125; Derived() &#123; System.out.println(\"Dervied constructor\"); &#125;&#125;public static void main(String[] args) &#123; Derived d = new Dervied();&#125; 输出1234567891011121314Base static block 1Base static fieldBase static block 2Static block 1Static fieldStatic block 2Base normal block 1Base normal fieldBase normal block 2Base constructorNormal block 1Normal fieldNormal block 2Dervied constructor 总结对象在class文件加载完毕，以及为各成员在方法区开辟好内存空间后，就开始所谓的初始化步骤： 基类静态代码块，基类静态成员字段，无优先级，按先后顺序，只有第一次加载类时执行。 派生类静态代码块，派生类静态成员字段，无优先级，按先后顺序，只有第一次加载类时执行。 基类普通代码块，基类普通成员字段，无优先级，按先后顺序。 基类构造函数。 派生类普通代码块，派生类普通成员字段，无优先级，按先后顺序。 派生类构造函数。 1和2的静态过程，只有在类第一次被加载的时候才执行如果创建两个对象：Dervied d1 = new Dervied();Dervied d1 = new Dervied();第二次创建只执行2345. reference[https://www.zhihu.com/question/49196023] (https://www.zhihu.com/question/49196023)https://github.com/frank-lam/fullstack-tutorial","categories":[{"name":"Java系列","slug":"Java系列","permalink":"http://yoursite.com/categories/Java系列/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]}]}